"use strict";function __assert(t,...e){if(!t){if(1===e.length)throw new Error(e[0]);if(2===e.length)throw new __AssertionError(e[0],e[1])}}function __assertFunction(t){__assert(__isFunction(t),"function",t)}function __assertArray(t){__assert(__isArray(t),"array",t)}function __assertNotEmpty(t){__assert(!__isEmpty(t),"Sequence is empty!")}function __assertIterable(t){__assert(__isIterable(t),"iterable",t)}function __assertCollection(t){__assert(__isCollection(t),"collection",t)}function __assertNumeric(t){__assert(__isNumeric(t),"numeric value",t)}function __assertNumberBetween(t,e,r=1/0){__assertNumeric(t),__assert(t>=e&&t<=r,`Number must be between ${e} and ${r}!`)}function __assertIndexInRange(t,e){__assertCollection(t),__assert(__isNumeric(e),"number",e),__assert(e>=0&&e<t.Count(),"Index is out of bounds")}function __defaultEqualityCompareFn(t,e){return __toJSON(t)===__toJSON(e)}function defaultComparator(t,e){return t<e?-1:e<t?1:0}function __isArray(t){return t instanceof Array}function __isFunction(t){return"function"==typeof t}function __isNumeric(t){return!isNaN(parseFloat(t))}function __isEmpty(t){return t[Symbol.iterator]().next().done}function __isIterable(t){return Symbol.iterator in Object(t)}function __isString(t){return"string"==typeof t}function __isCollection(t){return t instanceof __Collection}function __isGenerator(t){return t instanceof function*(){}.constructor}function __isUndefined(t){return void 0===t}function __isPredicate(t){return!__isNative(t)&&__isFunction(t)&&1==__getParameterCount(t)}function __isNative(t){return/native code/.test(Object(t).toString())||!!~__nativeConstructors.indexOf(t)}function __toJSON(t){return JSON.stringify(t)}function __aggregateCollection(t,e,r,n){__assertFunction(r),__assertFunction(n),__assertNotEmpty(t);let o=e;for(let e of t)o=r(o,e);return n(o)}function __removeDuplicates(t,e=__defaultEqualityCompareFn){__assertIterable(t),__assertFunction(e);const r=[];return new __Collection(function*(){t:for(let n of t){for(let t of r)if(e(n,t))continue t;r.push(n),yield n}})}function __removeFromArray(t,e){__assertArray(t);let r,n,o=[];for(;(n=t.shift())&&!(r=__defaultEqualityCompareFn(n,e));)o.push(n);return t.unshift(...o),r}function __getDefault(t=Object){if(t&&__isNative(t)&&"function"==typeof t){let e=t();return e instanceof Object||t===Date?null:e}return t}function __getParameterCount(t){return __assertFunction(t),t.length}function __getComparatorFromKeySelector(t,e=defaultComparator){if(__isFunction(t))return new Function("comparator","keySelectorFn","a","b","return comparator(keySelectorFn(a), keySelectorFn(b))").bind(null,e,t);if(__isString(t))return t.startsWith("[")||t.startsWith(".")||(t=`.${t}`),new Function("comparator","a","b",`return comparator(a${t}, b${t})`).bind(null,e);throw new __AssertionError("string or function",t)}function extendIterablePrototype(t){for(let e of Object.getOwnPropertyNames(Object.getPrototypeOf(exports.Collection.Empty)))!e.startsWith("_")&&__isFunction(exports.Collection.Empty[e])&&(t[e]=function(...t){let r=exports.Collection.from(this);return r[e].call(r,...t)})}Object.defineProperty(exports,"__esModule",{value:!0});class __AssertionError extends Error{constructor(t,e){super(`Expected ${t}, got ${e}!`)}}exports.defaultComparator=defaultComparator;const __nativeConstructors=[Object,Number,Boolean,String,Symbol];class __Collection{constructor(t){this.__iterable=null,__assert(__isIterable(t)||__isGenerator(t),"iterable or generator",t),this.__iterable=t}[Symbol.iterator](){const t=this.__iterable;return __isGenerator(t)?t():function*(){yield*t}()}__resultOrDefault(t,e=(t=>!0),r=Object){let n;__isPredicate(e)?n=e:(n=(t=>!0),r=e),__assertFunction(n);const o=__getDefault(r);if(__isEmpty(this))return o;let _=t.call(this,n);return _||o}ElementAt(t){return __assertIndexInRange(this,t),this.Skip(t).Take(1).ToArray()[0]}Take(t=0){if(__assertNumeric(t),t<=0)return __Collection.Empty;const e=this;return new __Collection(function*(){let r=0;for(let n of e)if(yield n,++r===t)break})}Skip(t=0){return __assertNumeric(t),t<=0?this:this.SkipWhile((e,r)=>r<t)}TakeWhile(t=((t,e)=>!0)){__assertFunction(t);const e=this;return new __Collection(function*(){let r=0;for(let n of e){if(!t(n,r++))break;yield n}})}TakeUntil(t=((t,e)=>!1)){return this.TakeWhile((e,r)=>!t(e,r))}SkipWhile(t=((t,e)=>!0)){__assertFunction(t);const e=this;return new __Collection(function*(){let r=0,n=!1;for(let o of e)!n&&t(o,r++)||(n=!0,yield o)})}SkipUntil(t=((t,e)=>!1)){return this.SkipWhile((e,r)=>!t(e,r))}First(t=(t=>!0)){return __assertFunction(t),__assertNotEmpty(this),this.SkipWhile(e=>!t(e)).Take(1).ToArray()[0]}FirstOrDefault(t=(t=>!0),e=Object){return this.__resultOrDefault(this.First,t,e)}Last(t=(t=>!0)){return __assertFunction(t),__assertNotEmpty(this),this.Reverse().First(t)}LastOrDefault(t=(t=>!0),e=Object){return this.__resultOrDefault(this.Last,t,e)}Single(t=(t=>!0)){__assertFunction(t),__assertNotEmpty(this);let e;for(let r of this){if(t(r)){e=r;break}0}if(this.First(r=>t(r)&&!__defaultEqualityCompareFn(r,e)))throw new Error("Sequence contains more than one element");return e}SingleOrDefault(t=(t=>!0),e=Object){return this.__resultOrDefault(this.Single,t,e)}DefaultIfEmpty(t){return __isEmpty(this)?new __Collection([__getDefault(t)]):this}Concat(t){__assertIterable(t);const e=this;return new __Collection(function*(){yield*e,yield*t})}Union(t,e=__defaultEqualityCompareFn){return __assertIterable(t),this.Concat(t).Distinct(e)}Join(t,e,r,n,o=__defaultEqualityCompareFn){__assertIterable(t),__assertFunction(e),__assertFunction(r),__assertFunction(n),__assertFunction(o);const _=this;return new __Collection(function*(){for(let i of _){const _=e(i);for(let e of t){const t=r(e);o(_,t)&&(yield n(i,e))}}})}Except(t){__assertIterable(t),__isCollection(t)||(t=new __Collection(t));const e=this;return new __Collection(function*(){for(let r of e)t.Contains(r)||(yield r)})}Zip(t,e){__assertIterable(t),__assertFunction(e);const r=this;return new __Collection(function*(){const n=t[Symbol.iterator]();for(let t of r){const r=n.next();if(r.done)break;yield e(t,r.value)}})}Intersect(t,e=__defaultEqualityCompareFn){__assertIterable(t),__assertFunction(e);const r=this;return new __Collection(function*(){const n=__Collection.from(t);for(let t of r)n.Any(r=>e(t,r))&&(yield t)})}SequenceEqual(t,e=__defaultEqualityCompareFn){if(!__isIterable(t))return!1;const r=this.ToArray();if(t=__Collection.from(t).ToArray(),r.length!==t.length)return!1;for(let n=0;n<r.length;n++){if(!e(r[n],t[n]))return!1}return!0}static __getEqualKey(t,e,r){for(let n of t.keys())if(r(n,e))return n;return e}GroupBy(t,...e){function r(t){let e=2===__getParameterCount(t);try{e=e&&t(1,1)&&!t(1,2)}catch(t){e=!1}return e}function n(t){return i(t,t=>t,void 0,__defaultEqualityCompareFn)}function o(t,e){let n,o;return r(e)?(n=e,o=(t=>t)):(n=__defaultEqualityCompareFn,o=e),_(t,o,n)}function _(t,e,n){let o,_,s;return r(n)?o=n:s=n,2===__getParameterCount(e)?s=e:_=e,o||(o=__defaultEqualityCompareFn),_||(_=(t=>t)),i(t,_,s,o)}function i(t,e,r,n){__assertFunction(t),__assertFunction(e),__assert(__isUndefined(r)||__isFunction(r),"resultSelector must be undefined or function!"),__assertFunction(n);let o,_=new Map;for(let r of s){const o=__Collection.__getEqualKey(_,t(r),n),i=e(r);_.has(o)?_.get(o).push(i):_.set(o,[i])}return o=r?__Collection.from(_).Select(t=>r(...t)):_}const s=this;let a;switch(e.length){case 0:a=n;break;case 1:a=o;break;case 2:a=_;break;case 3:a=i;break;default:throw new Error("GroupBy parameter count can not be greater than 4!")}return a(t,...e)}GroupJoin(t,e,r,n,o=__defaultEqualityCompareFn){__assertIterable(t),__assertFunction(e),__assertFunction(r),__assertFunction(n);let _=new Map;for(let n of this){const i=e(n);_.set(n,new __Collection(function*(){for(let e of t)o(i,r(e))&&(yield e)}))}return new __Collection(function*(){for(let[t,e]of _)yield n(t,e.ToArray())})}Add(t){this.Insert(t,this.Count())}Insert(t,e){__assert(e>=0&&e<=this.Count(),"Index is out of bounds!");const r=this.ToArray();this.__iterable=function*(){yield*r.slice(0,e),yield t,yield*r.slice(e,r.length)}}Remove(t){let e=this.ToArray();return!!__removeFromArray(e,t)&&(this.__iterable=function*(){yield*e},!0)}Min(t=(t=>t)){return __assertFunction(t),__assertNotEmpty(this),Math.min.apply(null,this.Select(t).ToArray())}Max(t=(t=>t)){return __assertFunction(t),__assertNotEmpty(this),Math.max.apply(null,this.Select(t).ToArray())}Sum(t=(t=>t)){return __assertNotEmpty(this),this.Select(t).Aggregate(0,(t,e)=>t+e)}Average(t=(t=>t)){return __assertNotEmpty(this),this.Sum(t)/this.Count()}Order(t=defaultComparator){return this.OrderBy(t=>t,t)}OrderDescending(t=defaultComparator){return this.OrderByDescending(t=>t,t)}OrderBy(t,e=defaultComparator){return __assertFunction(e),new __OrderedCollection(this,__getComparatorFromKeySelector(t,e))}OrderByDescending(t,e=defaultComparator){return new __OrderedCollection(this,__getComparatorFromKeySelector(t,(t,r)=>e(r,t)))}Shuffle(){return this.OrderBy(()=>Math.floor(3*Math.random())-1)}IndexOf(t,e=__defaultEqualityCompareFn){__assertFunction(e);let r=0;for(let n of this){if(e(n,t))return r;r++}return-1}LastIndexOf(t,e=__defaultEqualityCompareFn){__assertFunction(e);let r=0,n=-1;for(let o of this)e(o,t)&&(n=r),r++;return n}Contains(t,e=__defaultEqualityCompareFn){return!!~this.IndexOf(t,e)}Where(t=((t,e)=>!0)){__assertFunction(t);const e=this;return new __Collection(function*(){let r=0;for(let n of e)t(n,r)&&(yield n),r++})}ConditionalWhere(t,e){return t?this.Where(e):this}Count(t=(t=>!0)){let e=0,r=this.Where(t)[Symbol.iterator]();for(;!r.next().done;)e++;return e}Any(t=null){return!__isEmpty(this)&&(!t||!this.Where(t)[Symbol.iterator]().next().done)}All(t=(t=>!0)){return __assertFunction(t),!this.Any(e=>!t(e))}Aggregate(t,e=null,r=null){return!__isFunction(t)||e||r?__isFunction(t)||!__isFunction(e)||r?__aggregateCollection(this,t,e,r):__aggregateCollection(this,t,e,t=>t):__aggregateCollection(this.Skip(1),this.First(),t,t=>t)}Select(t=(t=>t)){const e=this;let r=0;return new __Collection(function*(){for(let n of e)yield t(n,r),r++})}Flatten(){return this.SelectMany(t=>t)}SelectMany(t,e=((t,e)=>e)){__assertFunction(t),__assertFunction(e);const r=this;return new __Collection(function*(){let n=0;for(let o of r){let r=t(o,n),_=r;_=__isIterable(r)?r:[r];for(let t of _[Symbol.iterator]())yield e(o,t);n++}})}Distinct(t=__defaultEqualityCompareFn){return __assertFunction(t),__removeDuplicates(this,t)}ToArray(){return[...this]}ToDictionary(t,e=null,r=null){if(__assertFunction(t),!e&&!r)return this.ToDictionary(t,t=>t,__defaultEqualityCompareFn);if(!r&&1===__getParameterCount(e))return this.ToDictionary(t,e,__defaultEqualityCompareFn);if(!r&&2===__getParameterCount(e))return this.ToDictionary(t,t=>t,e);__assertFunction(r),__assertFunction(e);let n=[],o=new Map;const _=this.ToArray();for(let i of _){let _=t(i),s=e(i);__assert(null!=_,"Key is not allowed to be null!"),__assert(!__Collection.from(n).Any(t=>r(t,_)),`Key '${_}' is already in use!`),n.push(_),o.set(_,s)}return o}ToJSON(){return __toJSON(this.ToArray())}Reverse(){const t=this.ToArray();return new __Collection(function*(){for(let e=t.length-1;e>=0;e--)yield t[e]})}ForEach(t){__assertFunction(t);for(let e of this)t(e)}static from(t){return new __Collection(t)}static Range(t,e){return __assertNumberBetween(e,0,1/0),new __Collection(function*(){let r=t;for(;r!=e+t;)yield r++})}static Repeat(t,e){return __assertNumberBetween(e,0,1/0),new __Collection(function*(){for(let r=0;r<e;r++)yield t})}static get Empty(){return new __Collection([])}}__Collection.From=__Collection.from;class __HeapElement{constructor(t,e){this.__index=t,this.__value=e}static __createHeapElement(t,e){return void 0===e||e instanceof __HeapElement?e:new __HeapElement(t,e)}}class __MinHeap{constructor(t,e=defaultComparator){__assertArray(t),__assertFunction(e),this.__elements=t,this.__comparator=((t,r)=>{let n=e(t.__value,r.__value);return 0!==n?n:defaultComparator(t.__index,r.__index)}),this.__createHeap(this.__elements,this.__comparator)}__heapify(t,e,r){let n=2*(r+1),o=n-1,_=r;if(t[_]=__HeapElement.__createHeapElement(_,t[_]),o<t.length&&(t[o]=__HeapElement.__createHeapElement(o,t[o]),e(t[o],t[_])<0&&(_=o)),n<t.length&&(t[n]=__HeapElement.__createHeapElement(n,t[n]),e(t[n],t[_])<0&&(_=n)),_!==r){let n=t[r];t[r]=t[_],t[_]=n,this.__heapify(t,e,_)}}__createHeap(t,e){if(0!==t.length)for(let r=Math.floor(t.length/2);r>=0;r--)this.__heapify(t,e,r)}__hasTopElement(){return this.__elements.length>0}__getTopElement(){if(1===this.__elements.length)return this.__elements.pop().__value;let t=this.__elements[0];return this.__elements[0]=this.__elements.pop(),this.__heapify(this.__elements,this.__comparator,0),t.__value}[Symbol.iterator](){let t=this;return{next:function(){return t.__hasTopElement()?{done:!1,value:t.__getTopElement()}:{done:!0,value:void 0}}}}}exports.__MinHeap=__MinHeap;class __OrderedCollection extends __Collection{constructor(t,e){__assertFunction(e),super(t),this.__comparator=e}ThenBy(t,e=defaultComparator){const r=this.__comparator,n=__getComparatorFromKeySelector(t,e);return new __OrderedCollection(this.__iterable,(t,e)=>{const o=r(t,e);return 0!==o?o:n(t,e)})}ThenByDescending(t,e=defaultComparator){return this.ThenBy(t,(t,r)=>e(r,t))}[Symbol.iterator](){let t=this,e=super[Symbol.iterator].bind(this);return function*(){yield*new __MinHeap([...{[Symbol.iterator]:e}],t.__comparator)}()}}exports.Collection=__Collection,exports.default=exports.Collection,exports.extendIterablePrototype=extendIterablePrototype;