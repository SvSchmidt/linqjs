/*!
 * linqjs v0.0.0
 * (c) Sven Schmidt 
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */
(function(){'use strict';
const window=this||(0,eval)('this');const DEBUG=!0;(function(Collection){try{if(typeof define==='function'&&define.amd){define(['require','exports'],function(){return Collection })} else if(exports&&module&&module.exports){exports=module.exports=Collection}} catch(err){window.Collection=Collection}}(function(){let linqjsExports={}
let Collection;Collection=(function(){function Collection(S){O(l1(S)||m1(S),'Parameter must be nc or generator!');this.nc=S}
Collection.prototype=(function(){function next(){if(!this.started){this.started=!0;this.iterator=this.x1()}
return this.iterator.next()}
function c1(){this.started=!1}
function x1(){const iter=this.nc;if(m1(iter)){return iter()} else{return function*(){yield* iter}()}}return{next,c1,x1 }}());Collection.prototype[Symbol.iterator]=function*(){let wd;while(!0){wd=this.next();if(wd.done){this.c1();break}
yield wd.value}}
return Collection}());function From(nc){return new Collection(nc)}
function Range(start,wc){H(wc,0,Infinity);return new Collection(function*(){let i=start;while(i!=wc+start){yield i++}})}
function Repeat(val,wc){H(wc,0,Infinity);return new Collection(function*(){for(let i=0;i<wc;i++){yield val}})}Object.defineProperty(Collection,'Empty',{get:function(){return Collection.from([])}});const hcStaticMethods={From,from:From,Range,Repeat }
E(Collection,hcStaticMethods);function A(uc,rc){return a1(uc)===a1(rc)}
function defaultComparator(a,b){if(a<b){return -1}
if(b<a){return 1}
return 0}class AssertionError extends Error{constructor(expected,got){super(`Expected ${expected},got ${got}!`)}}
function O(lc,...cds){if(!lc){if(cds.length===1){throw new Error(msg)} else if(cds.length===2){throw new AssertionError(...cds)}}}
function L(xc){O(n1(xc),'function',xc)}
function N(xc){O(q1(xc),'dday',xc)}
function I(bd){O(!o1(bd),'Sequence is empty!')}
function J(ed){O(l1(ed),'nc',ed)}
function M(ed){O(p1(ed),'hc',ed)}
function F(ed){O(h1(ed),'string',ed)}
function G(ed){O(i(ed),'numeric value',ed)}function H(num,min,max=Infinity){G(num);O(num>=min&&num<=max,`Number must be between ${min} and ${max}!`)}
function K(bd,index){M(bd);O(i(index),'number',index);O(index>=0&&index<bd.Count(),'Index is out of bounds')}
function q1(ed){return ed instanceof([]).constructor}
function n1(ed){return typeof ed==='function'}
function i(n){return !isNaN(parseFloat(n))}
function o1(bd){if(p1(bd)){return o1(bd.Take(1).ToArray())}
return bd.length===0}
function l1(ed){return(Symbol.iterator in Object(ed))}
function h1(ed){return typeof ed==='string'}
function p1(ed){return ed instanceof Collection}function m1(ed){return ed instanceof(function*(){}).constructor}
function g1(ed){return typeof ed===typeof undefined}
function a1(ed){return JSON.stringify(ed)}
function E(tcdet,source){Object.assign(Object(tcdet),source);return tcdet}
function D(ed){E(linqjsExports,ed)}
function f1(xc,value){return typeof xc==='undefined'?value:xc}
function C(bd,zc,fc,W){L(fc);L(W);I(bd);return W([zc].concat(bd).reduce(fc))}
function e1(bd,X=A){J(bd);L(X);const md=[];return new Collection(function*(){const iter=bd.x1();td:for(let val of iter){yc:for(let prev of md){if(X(val,prev)){continue td}}
md.push(val);yield val}})}
function d1(dd,value){N(dd);let acsBefore=[];let acFound=!1;let wd;while((wd=dd.shift())&&!(acFound=A(wd,value))){acsBefore.push(wd)}
dd.unshift(...acsBefore);return acFound}
const fd=[Object,Number,Boolean,String,Symbol];function j1(ed){return /native code/.test(Object(ed).toString())||!!~fd.indexOf(ed)}
function z1(U=Object){if(U&&j1(U)&&typeof U==='function'){let kdue=U();if(kdue instanceof Object||U===Date){return null} else{return kdue}}
return U}
function w1(fn){L(fn);return fn.length}
function Min(tc=x=>x){L(tc);I(this);return Math.min.apply(null,this.Select(tc).ToArray())}
function Max(tc=x=>x){L(tc);I(this);return Math.max.apply(null,this.Select(tc).ToArray())}
function Sum(tc=x=>x){I(this);return this.Select(tc).Aggregate(0,(prev,curr)=>prev+curr)}
function Average(tc=x=>x){I(this);return this.Sum(tc)/ this.Count()}
function Concat(yc){J(yc);const td=this;return new Collection(function*(){yield* td.x1();yield* yc})}
function Union(yc,X=A){J(yc);return this.Concat(yc).Distinct(X)}
function Join(yc,Z,Y,aa,R){J(yc);L(Z);L(Y);L(aa);R=f1(R,A);L(R);const td=this;return new Collection(function*(){for(let gd of td.x1()){const tdKey=Z(gd);for(let ycValue of yc[Symbol.iterator]()){const ycKey=Y(ycValue);if(R(tdKey,ycKey)){yield aa(gd,ycValue)}}}})}
function Except(yc){J(yc);if(!p1(yc)){yc=new Collection(yc)}
const td=this;return new Collection(function*(){for(let val of td.x1()){if(!yc.Contains(val)){yield val}}})}
function Zip(yc,aa){J(yc);L(aa);const td=this;return new Collection(function*(){const ycIter=yc[Symbol.iterator]();for(let nd of td.x1()){const ycNext=ycIter.next();if(ycNext.done){break}
yield aa(nd,ycNext.value)}})}
function Intersect(yc,X=A){J(yc);L(X);const tdIter=this.ToArray();return new Collection(function*(){const ycIter=[...yc];for(let val of tdIter){if(ycIter.Any(ac=>X(val,ac))){yield val}}})}
function IndexOf(qc,X=A){L(X);const iter=this.x1();let i=0;for(let val of iter){if(X(val,qc)){return i}
i++}
return -1}
function LastIndexOf(qc,X=A){L(X);const iter=this.x1();let i=0;let rd=-1;for(let val of iter){if(X(val,qc)){rd=i}
i++}
return rd}
function Contains(ac,X=A){return !!~this.IndexOf(ac,X)}
function Where(kc=(ac,index)=>!0){L(kc);const iter=this.x1();const ld=new Collection(function*(){let index=0;for(let val of iter){if(kc(val,index)){yield val}
index++}});return ld}
function ConditionalWhere(lc,kc){if(lc){return this.Where(kc)} else{return this}}
function Count(kc=ac=>!0){let wc=0;
let filtered=this.Where(kc);
while(!filtered.next().done){wc++}
return wc}
function Any(kc){if(o1(this)){return !1}
if(!kc){return !0}
return !this.Where(kc).next().done}
function All(kc=ac=>!0){L(kc);return !this.Any(x=>!kc(x))}
function b1(hc,ic,T=x=>!0,mc=Object){let kc;if(j1(T)||!n1(T)){kc=x=>!0;mc=T} else{kc=T}
L(kc);const kd=z1(mc);if(o1(hc)){return kd}
let ld=ic.call(hc,kc);if(!ld){return kd}
return ld}
function ElementAt(index){K(this,index);const ld=this.Skip(index).Take(1).ToArray()[0];this.c1();return ld}
function Take(wc=0){G(wc);if(wc<=0){return Collection.Empty}
const iter=this.x1();return new Collection(function*(){let i=0;for(let val of iter){yield val;if(++i===wc){break}}})}
function Skip(wc=0){G(wc);if(wc<=0){return this}
return this.SkipWhile((ac,index)=>index<wc)}
function TakeWhile(kc=(ac,index)=>!0){L(kc);const _self=this;const ld=new Collection(function*(){let index=0;let endTake=!1;for(let val of _self.x1()){if(!endTake&&kc(val,index++)){yield val;continue}
endTake=!0}});this.c1();return ld}
function TakeUntil(kc=(ac,index)=>!1){return this.TakeWhile((ac,index)=>!kc(ac,index))}
function SkipWhile(kc=(ac,index)=>!0){L(kc);const _self=this;return new Collection(function*(){let index=0;let endSkip=!1;for(let val of _self.x1()){if(!endSkip&&kc(val,index++)){continue}
endSkip=!0;yield val}})}
function SkipUntil(kc=(ac,index)=>!1){return this.SkipWhile((ac,index)=>!kc(ac,index))}
function First(kc=x=>!0){L(kc);I(this);const ld=this.SkipWhile(ac=>!kc(ac)).Take(1).ToArray()[0];this.c1();return ld}
function FirstOrDefault(Q=x=>!0,constructor=Object){return b1(this,First,Q,constructor)}
function Last(kc=x=>!0){L(kc);I(this);return this.Reverse().First(kc)}
function LastOrDefault(Q=x=>!0,constructor=Object){return b1(this,Last,Q,constructor)}
function Single(kc=x=>!0){L(kc);I(this);let index=0;let ld;for(let val of this.x1()){if(kc(val)){ld=val;break}
index++}
if(this.First(ac=>kc(ac)&&!A(ac,ld))){throw new Error('Sequence contains more than one qc')}
return ld}
function SingleOrDefault(Q=x=>!0,constructor=Object){return b1(this,Single,Q,constructor)}
function DefaultIfEmpty(U){if(!o1(this)){return this}
return [z1(U)]}
let HeapElement=(function(){function HeapElement(index,value){this.__index=index;
this.__value=value;
this.__isHeapElementInstance=!0}
HeapElement.CreateHeapElement=function(index,ed){if(ed===undefined||ed.__isHeapElementInstance){return ed}
return new HeapElement(index,ed)};
return HeapElement})();
let MinHeap=(function(){function MinHeap(pc,jc=defaultComparator){N(pc);
L(jc);
this.pc=pc;
this.jc=(a,b)=>{let res=jc(a.__value,b.__value);
if(res!==0){return res}
return defaultComparator(a.__index,b.__index)};
B(this.pc,this.jc)}
function r1(pc,jc,i){let right=2*(i+1);
let left=right-1;
let bestIndex=i;
pc[bestIndex]=HeapElement.CreateHeapElement(bestIndex,pc[bestIndex]);
if(left<pc.length){pc[left]=HeapElement.CreateHeapElement(left,pc[left]);
if(jc(pc[left],pc[bestIndex])<0){bestIndex=left}}
if(right<pc.length){pc[right]=HeapElement.CreateHeapElement(right,pc[right]);
if(jc(pc[right],pc[bestIndex])<0){bestIndex=right}}
if(bestIndex!==i){let tmp=pc[i];
pc[i]=pc[bestIndex];
pc[bestIndex]=tmp;
r1(pc,jc,bestIndex)}}
function B(pc,jc){if(pc.length===0){return}
for(let i=Math.floor(pc.length / 2);i>=0;i--){r1(pc,jc,i)}}
MinHeap.prototype.hasTopElement=function(){return this.pc.length>0};
MinHeap.prototype.getTopElement=function(){if(this.pc.length===1){return this.pc.pop().__value}
let topElement=this.pc[0];
let tmp=this.pc.pop();
this.pc[0]=tmp;
r1(this.pc,this.jc,0);
return topElement.__value};
MinHeap.prototype[Symbol.iterator]=function(){let heap=this;
return{next:function(){if(heap.hasTopElement()){return{done:!1,
value:heap.getTopElement()}}
return{done:!0}}}};
return MinHeap})();
let MaxHeap=(function(){function MaxHeap(pc,jc=defaultComparator){N(pc);
L(jc);MinHeap.apply(this,[pc,function(a,b){return -1*jc(a,b)}])}
MaxHeap.prototype=Object.create(MinHeap.prototype);
MaxHeap.prototype.constructor=MaxHeap;
return MaxHeap})();function Aggregate(V,fc,W){const values=this.ToArray();if(typeof V==='function'&&!fc&&!W){return C(values.slice(1,values.length),values.slice(0,1)[0],V,ac=>ac)} else if(typeof V!=='function'&&typeof fc==='function'&&!W){return C(values,V,fc,ac=>ac)} else{return C(values,V,fc,W)}}
function Select(tc=x=>x){const iter=this.x1();let index=0;return new Collection(function*(){for(let val of iter){yield tc(val,index);index ++}})}
function Flatten(){return this.SelectMany(x=>x)}
function SelectMany(tc,dc=(x,y)=>y){L(tc);L(dc);const iter=this.x1();return new Collection(function*(){let index=0;for(let wd of iter){let vd=tc(wd,index);let newIter=vd;if(!l1(vd)){newIter=[vd]} else{newIter=vd}
for(let val of newIter[Symbol.iterator]()){yield dc(wd,val)}
index++}})}
function Distinct(X=A){L(X);return e1(this,X)}
function ToArray(){return [...this.x1()]}
function ToDictionary(gc,P,ec){L(gc);if(!P&&!ec){return this.ToDictionary(gc,ac=>ac,A)} else if(!ec&&w1(P)===1){return this.ToDictionary(gc,P,A)} else if(!ec&&w1(P)===2){return this.ToDictionary(gc,ac=>ac,P)}L(ec);L(P);let usedKeys=[];let ld=new Map();const input=this.ToArray();const cc=P;for(let value of input){let key=gc(value);let ac=cc(value);O(key!=null,'Key is not allowed to be null!');O(!usedKeys.Any(x=>ec(x,key)),`Key '${key}' is already in use!`);usedKeys.push(key);ld.set(key,ac)}
return ld}
function ToJSON(){return a1(this.ToArray())}
function Reverse(){const dd=this.ToArray();return new Collection(function*(){for(let i=dd.length-1;i>=0;i--){yield dd[i]}})}
function ForEach(fn){L(fn);for(let val of this.x1()){fn(val)}}
function Add(value){this.Insert(value,this.Count())}
function Insert(value,index){O(index>=0&&index<=this.Count(),'Index is out of bounds!');const oldIter=this.ToArray();this.nc=function*(){yield* oldIter.slice(0,index);yield value;yield* oldIter.slice(index,oldIter.length)}}
function Remove(value){let values=this.ToArray();const ld=d1(values,value);if(!ld){return !1}
this.nc=function*(){yield* values}
return !0}
let OrderedCollection=(function(){function OrderedCollection(nc,jc,bc){J(nc);L(jc);L(bc);Collection.apply(this,[nc]);this.__jc=jc;this.__bc=bc}
OrderedCollection.prototype.ThenBy=function(ud){if(h1(ud)){ud=GetComparatorFromKeySelector(ud)}
L(ud);
let wdComparator=this.__jc;
this.__jc=(a,b)=>{let res=wdComparator(a,b);
if(res!==0){return res}
return ud(a,b)};
return this};
OrderedCollection.prototype.x1=function(){const _self=this;return function*(){yield* Reflect.construct(_self.__bc,[[..._self.nc],_self.__jc])}()}
return OrderedCollection})();
function GetComparatorFromKeySelector(oc){F(oc);if(oc===''){return defaultComparator}if(!(oc.startsWith('[')||oc.startsWith('.'))){oc=`.${oc}`}return new Function('jc','a','b',`return jc(a${oc},b${oc})`).bind(null,defaultComparator)}
function Order(){return this.OrderBy(defaultComparator)}
function OrderDescending(){return this.OrderByDescending(defaultComparator)}
function OrderBy(jc){if(h1(jc)){jc=GetComparatorFromKeySelector(jc)}
L(jc);
return new OrderedCollection(this,jc,MinHeap)};
function OrderByDescending(jc){if(h1(jc)){jc=GetComparatorFromKeySelector(jc)}
L(jc);
return new OrderedCollection(this,jc,MaxHeap)};
function Shuffle(){return this.OrderBy(()=>Math.floor(Math.random()*3)-1 )}
function y1(sc,key,ec){for(let zd of sc.keys()){if(ec(zd,key)){return zd}}
return key}
function GroupBy(gc,...cds){const dd=this.ToArray();function k1(cd){let ld=w1(cd)===2;try{ld=ld&&cd(1,1)&&!cd(1,2)} catch(err){ld=!1}
return ld}
function u1(gc){return v1(gc,ac=>ac,undefined,A)}
function s1(gc,yc){let ec,cc;if(k1(yc)){ec=yc;cc=ac=>ac} else{ec=A;cc=yc}
return t1(gc,cc,ec)}
function t1(gc,yc,vc){let ec,cc,dc;if(k1(vc)){ec=vc} else{dc=vc}
if(w1(yc)===2){dc=yc} else{cc=yc}
if(!ec){ec=A}
if(!cc){cc=ac=>ac}
return v1(gc,cc,dc,ec)}
function v1(gc,cc,dc,ec){L(gc);L(cc);O(g1(dc)||n1(dc),'dc must be undefined or function!');L(ec);let sc=new Map();let ld;for(let val of dd){const key=y1(sc,gc(val),ec);const ac=cc(val);if(sc.has(key)){sc.get(key).push(ac)} else{sc.set(key,[ac])}}
if(dc){ld=sc.ToArray().Select(g=>dc(...g))} else{ld=sc}
return ld}
let fn;switch(cds.length){case 0:;fn=u1;break;case 1:;fn=s1;break;case 2:;fn=t1;break;case 3:;fn=v1;break;default:;throw new Error('GroupBy xceter wc can not be greater than 4!')}
return fn(gc,...cds)}
function GroupJoin(yc,Z,Y,dc,X=A){J(yc);L(Z);L(Y);L(dc);let sc=new Map();const td=this;for(let nd of td.x1()){const tdKey=Z(nd);sc.set(nd,new Collection(function*(){for(let ycVal of yc[Symbol.iterator]()){if(X(tdKey,Y(ycVal))){yield ycVal}}}))}
return new Collection(function*(){for(let [key,values] of sc){yield dc(key,values.ToArray())}})}
function SequenceEqual(rc,X=A){if(!l1(rc)){return !1}
const uc=this.ToArray();rc=rc.ToArray();if(uc.length!==rc.length){return !1}
for(let i=0;i<uc.length;i++){let ucVal=uc[i];let rcVal=rc[i];if(!X(ucVal,rcVal)){return !1}}
return !0}D({defaultComparator,Min,Max,Average,Sum,Concat,Union,Join,Except,Zip,Intersect,Where,ConditionalWhere,Count,Contains,IndexOf,LastIndexOf,Any,All,ElementAt,Take,TakeWhile,TakeUntil,Skip,SkipWhile,SkipUntil,Contains,First,FirstOrDefault,Last,LastOrDefault,Single,SingleOrDefault,DefaultIfEmpty,MinHeap,MaxHeap,Aggregate,Distinct,Select,SelectMany,Flatten,Reverse,ToArray,ToDictionary,ToJSON,ForEach,Add,Insert,Remove,GetComparatorFromKeySelector,OrderedCollection,Order,OrderBy,OrderDescending,OrderByDescending,Shuffle,GroupBy,GroupJoin,SequenceEqual });E(Collection.prototype,linqjsExports);OrderedCollection.prototype=E(E({},Collection.prototype),OrderedCollection.prototype);OrderedCollection.prototype.constructor=OrderedCollection;const protosToApplyWrappers=[window.Array.prototype,window.Set.prototype,window.Map.prototype];Object.keys(Collection.prototype).forEach(k=>{for(let proto of protosToApplyWrappers){proto[k]=function(...cds){return new Collection(this)[k](...cds)}}});return Collection}()))}());