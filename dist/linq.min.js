/*!
 * linqjs v0.0.0
 * (c) Sven Schmidt 
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */
(function(){'use strict';const window=this||(0,eval)('this');const DEBUG=!0;(function(Collection){try{if(typeof define==='function'&&define.amd){define(['require','exports'],function(){return Collection })}else if(exports&&module&&module.exports){exports=module.exports=Collection}} catch(err){window.Collection=Collection}}(function(){let linqjsExports={}
let Collection=(function(){function Collection(S){O(l(S)||m(S),'Parameter must be iterable or generator!');this.iterable=S}
Collection.prototype=(function(){function next(c=!1){if(c||!this.started){this.started=!0;this.iterator=this.x()}
return this.iterator.next()}
function c(){this.started=!1}
function x(){const iter=this.iterable;if(m(iter)){return iter()}else{return function*(){yield* iter}()}}return{next,c,x }}());Collection.prototype[Symbol.iterator]=function*(){let vd;while(!0){vd=this.next();if(vd.done){this.c();break}
yield vd.value}}
return Collection}());function From(iterable){return new Collection(iterable)}
function Range(start,vc){H(vc,0,1/0);return new Collection(function*(){let i=start;while(i!=vc+start){yield i++}})}
function Repeat(val,vc){H(vc,0,1/0);return new Collection(function*(){for(let i=0;i<vc;i++){yield val}})}Object.defineProperty(Collection,'Empty',{get:function(){return Collection.from([])}});const pd={From,from:From,Range,Repeat }
E(Collection,pd);function A(sc,pc){return a(sc)===a(pc)}
function defaultComparator(a,b){if(a<b){return -1}
if(b<a){return 1}
return 0}class AssertionError extends Error{constructor(expected,got){super(`Expected ${expected},got ${got}!`)}}
function O(jc,...bds){if(!jc){if(bds.length===1){throw new Error(bds[0])}else if(bds.length===2){throw new AssertionError(...bds)}}}
function L(uc){O(n(uc),'function',uc)}
function N(uc){O(q(uc),'array',uc)}
function I(xc){O(!o(xc),'Sequence is empty!')}
function J(ac){O(l(ac),'iterable',ac)}
function M(ac){O(p(ac),'collection',ac)}
function F(ac){O(h(ac),'string',ac)}
function G(ac){O(i(ac),'numeric value',ac)}function H(num,min,max=1/0){G(num);O(num>=min&&num<=max,`Number must be between ${min} and ${max}!`)}
function K(xc,index){M(xc);O(i(index),'number',index);O(index>=0&&index<xc.Count(),'Index is out of bounds')}
function q(ac){return ac instanceof([]).constructor}
function n(ac){return typeof ac==='function'}
function i(n){return !isNaN(parseFloat(n))}
function o(coll){if(p(coll)){return coll.next(!0).done}
return coll.length===0}
function l(ac){return(Symbol.iterator in Object(ac))}
function h(ac){return typeof ac==='string'}
function p(ac){return ac instanceof Collection}function m(ac){return ac instanceof(function*(){}).constructor}
function g(ac){return typeof ac===typeof undefined}
function a(ac){return JSON.stringify(ac)}
function E(tbdet,source){Object.assign(Object(tbdet),source);return tbdet}
function D(ac){E(linqjsExports,ac)}
function f(uc,value){return typeof uc==='undefined'?value:uc}
function C(coll,yc,fc,W){L(fc);L(W);I(coll);return W([yc].concat(coll).reduce(fc))}
function e(coll,X=A){J(coll);L(X);const jd=[];return new Collection(function*(){const iter=coll.x();qd:for(let val of iter){qc:for(let prev of jd){if(X(val,prev)){continue qd}}
jd.push(val);yield val}})}
function d(arr,value){N(arr);let zcsBefore=[];let zcFound=!1;let vd;while((vd=arr.shift())&&!(zcFound=A(vd,value))){zcsBefore.push(vd)}
arr.unshift(...zcsBefore);return zcFound}
const cd=[Object,Number,Boolean,String,Symbol];function j(ac){return /native code/.test(Object(ac).toString())||!!~cd.indexOf(ac)}
function z(U=Object){if(U&&j(U)&&typeof U==='function'){let hdue=U();if(hdue instanceof Object||U===Date){return null}else{return hdue}}
return U}
function w(fn){L(fn);return fn.length}
function Min(wc=x=>x){L(wc);I(this);return Math.min.apply(null,this.Select(wc).ToArray())}
function Max(wc=x=>x){L(wc);I(this);return Math.max.apply(null,this.Select(wc).ToArray())}
function Sum(wc=x=>x){I(this);return this.Select(wc).Aggregate(0,(prev,curr)=>prev+curr)}
function Average(wc=x=>x){I(this);return this.Sum(wc)/ this.Count()}
function Concat(qc){J(qc);const qd=this;return new Collection(function*(){yield* qd.x();yield* qc})}
function Union(qc,X=A){J(qc);return this.Concat(qc).Distinct(X)}
function Join(qc,Z,Y,aa,R){J(qc);L(Z);L(Y);L(aa);R=f(R,A);L(R);const qd=this;return new Collection(function*(){for(let dd of qd.x()){const qdKey=Z(dd);for(let qcValue of qc[Symbol.iterator]()){const qcKey=Y(qcValue);if(R(qdKey,qcKey)){yield aa(dd,qcValue)}}}})}
function Except(qc){J(qc);if(!p(qc)){qc=new Collection(qc)}
const qd=this;return new Collection(function*(){for(let val of qd.x()){if(!qc.Contains(val)){yield val}}})}
function Zip(qc,aa){J(qc);L(aa);const qd=this;return new Collection(function*(){const qcIter=qc[Symbol.iterator]();for(let kd of qd.x()){const qcNext=qcIter.next();if(qcNext.done){break}
yield aa(kd,qcNext.value)}})}
function Intersect(qc,X=A){J(qc);L(X);const qdIter=this.ToArray();return new Collection(function*(){const qcIter=[...qc];for(let val of qdIter){if(qcIter.Any(zc=>X(val,zc))){yield val}}})}
function IndexOf(nc,X=A){L(X);let i=0;for(let val of this.x()){if(X(val,nc)){return i}
i++}
return -1}
function LastIndexOf(nc,X=A){L(X);let i=0;let od=-1;for(let val of this.x()){if(X(val,nc)){od=i}
i++}
return od}
function Contains(zc,X=A){return !!~this.IndexOf(zc,X)}
function Where(ic=(zc,index)=>!0){L(ic);const xc=this;const id=new Collection(function*(){let index=0;for(let val of xc.x()){if(ic(val,index)){yield val}
index++}});return id}
function ConditionalWhere(jc,ic){if(jc){return this.Where(ic)}else{return this}}
function Count(ic=zc=>!0){let vc=0;let filtered=this.Where(ic);while(!filtered.next().done){vc++}
return vc}
function Any(ic){if(o(this)){return !1}
if(!ic){return !0}
return !this.Where(ic).next().done}
function All(ic=zc=>!0){L(ic);return !this.Any(x=>!ic(x))}
function b(xc,gc,T=x=>!0,kc=Object){let ic;if(j(T)||!n(T)){ic=x=>!0;kc=T}else{ic=T}
L(ic);const hd=z(kc);if(o(xc)){return hd}
let id=gc.call(xc,ic);if(!id){return hd}
return id}
function ElementAt(index){K(this,index);const id=this.Skip(index).Take(1).ToArray()[0];this.c();return id}
function Take(vc=0){G(vc);if(vc<=0){return Collection.Empty}
const xc=this;return new Collection(function*(){let i=0;for(let val of xc.x()){yield val;if(++i===vc){break}}})}
function Skip(vc=0){G(vc);if(vc<=0){return this}
return this.SkipWhile((zc,index)=>index<vc)}
function TakeWhile(ic=(zc,index)=>!0){L(ic);const xc=this;const id=new Collection(function*(){let index=0;let endTake=!1;for(let val of xc.x()){if(!endTake&&ic(val,index++)){yield val;continue}
endTake=!0}});this.c();return id}
function TakeUntil(ic=(zc,index)=>!1){return this.TakeWhile((zc,index)=>!ic(zc,index))}
function SkipWhile(ic=(zc,index)=>!0){L(ic);const xc=this;return new Collection(function*(){let index=0;let zd=!1;for(let val of xc.x()){if(!zd&&ic(val,index++)){continue}
zd=!0;yield val}})}
function SkipUntil(ic=(zc,index)=>!1){return this.SkipWhile((zc,index)=>!ic(zc,index))}
function First(ic=x=>!0){L(ic);I(this);const id=this.SkipWhile(zc=>!ic(zc)).Take(1).ToArray()[0];this.c();return id}
function FirstOrDefault(Q=x=>!0,constructor=Object){return b(this,First,Q,constructor)}
function Last(ic=x=>!0){L(ic);I(this);return this.Reverse().First(ic)}
function LastOrDefault(Q=x=>!0,constructor=Object){return b(this,Last,Q,constructor)}
function Single(ic=x=>!0){L(ic);I(this);let index=0;let id;for(let val of this.x()){if(ic(val)){id=val;break}
index++}
if(this.First(zc=>ic(zc)&&!A(zc,id))){throw new Error('Sequence contains more than one nc')}
return id}
function SingleOrDefault(Q=x=>!0,constructor=Object){return b(this,Single,Q,constructor)}
function DefaultIfEmpty(U){if(!o(this)){return this}
return [z(U)]}
let ad=(function(){function ad(index,value){this.__index=index;this.__value=value;this.__isadInstance=!0}
ad.Createad=function(index,ac){if(ac===undefined||ac.__isadInstance){return ac}
return new ad(index,ac)};return ad})();let MinHeap=(function(){function MinHeap(lc,hc=defaultComparator){N(lc);L(hc);this.lc=lc;this.hc=(a,b)=>{let res=hc(a.__value,b.__value);if(res!==0){return res}
return defaultComparator(a.__index,b.__index)};B(this.lc,this.hc)}
function r(lc,hc,i){let sd=2*(i+1);let rd=sd-1;let bestIndex=i;lc[bestIndex]=ad.Createad(bestIndex,lc[bestIndex]);if(rd<lc.length){lc[rd]=ad.Createad(rd,lc[rd]);if(hc(lc[rd],lc[bestIndex])<0){bestIndex=rd}}
if(sd<lc.length){lc[sd]=ad.Createad(sd,lc[sd]);if(hc(lc[sd],lc[bestIndex])<0){bestIndex=sd}}
if(bestIndex!==i){let tmp=lc[i];lc[i]=lc[bestIndex];lc[bestIndex]=tmp;r(lc,hc,bestIndex)}}
function B(lc,hc){if(lc.length===0){return}
for(let i=Math.floor(lc.length / 2);i>=0;i--){r(lc,hc,i)}}
MinHeap.prototype.be=function(){return this.lc.length>0};MinHeap.prototype.getTopElement=function(){if(this.lc.length===1){return this.lc.pop().__value}
let topElement=this.lc[0];let tmp=this.lc.pop();this.lc[0]=tmp;r(this.lc,this.hc,0);return topElement.__value};MinHeap.prototype[Symbol.iterator]=function(){let heap=this;return{next:function(){if(heap.be()){return{done:!1,
value:heap.getTopElement()}}
return{done:!0}}}};return MinHeap})();function Aggregate(V,fc,W){const values=this.ToArray();if(typeof V==='function'&&!fc&&!W){return C(values.slice(1,values.length),values.slice(0,1)[0],V,zc=>zc)}else if(typeof V!=='function'&&typeof fc==='function'&&!W){return C(values,V,fc,zc=>zc)}else{return C(values,V,fc,W)}}
function Select(wc=x=>x){const xc=this;let index=0;return new Collection(function*(){for(let val of xc.x()){yield wc(val,index);index ++}})}
function Flatten(){return this.SelectMany(x=>x)}
function SelectMany(wc,cc=(x,y)=>y){L(wc);L(cc);const iter=this.x();return new Collection(function*(){let index=0;for(let vd of iter){let ud=wc(vd,index);let newIter=ud;if(!l(ud)){newIter=[ud]}else{newIter=ud}
for(let val of newIter[Symbol.iterator]()){yield cc(vd,val)}
index++}})}
function Distinct(X=A){L(X);return e(this,X)}
function ToArray(){return [...this.x()]}
function ToDictionary(ec,P,dc){L(ec);if(!P&&!dc){return this.ToDictionary(ec,zc=>zc,A)}else if(!dc&&w(P)===1){return this.ToDictionary(ec,P,A)}else if(!dc&&w(P)===2){return this.ToDictionary(ec,zc=>zc,P)}L(dc);L(P);let usedKeys=[];let id=new Map();const input=this.ToArray();const bc=P;for(let value of input){let key=ec(value);let zc=bc(value);O(key!=null,'Key is not allowed to be null!');O(!usedKeys.Any(x=>dc(x,key)),`Key '${key}' is already in use!`);usedKeys.push(key);id.set(key,zc)}
return id}
function ToJSON(){return a(this.ToArray())}
function Reverse(){const arr=this.ToArray();return new Collection(function*(){for(let i=arr.length-1;i>=0;i--){yield arr[i]}})}
function ForEach(fn){L(fn);for(let val of this.x()){fn(val)}}
function Add(value){this.Insert(value,this.Count())}
function Insert(value,index){O(index>=0&&index<=this.Count(),'Index is out of bounds!');const oldIter=this.ToArray();this.iterable=function*(){yield* oldIter.slice(0,index);yield value;yield* oldIter.slice(index,oldIter.length)}}
function Remove(value){let values=this.ToArray();const id=d(values,value);if(!id){return !1}
this.iterable=function*(){yield* values}
return !0}
let OrderedCollection=(function(){function OrderedCollection(S,hc){L(hc);Collection.apply(this,[S]);this.__hc=hc}
OrderedCollection.prototype.ThenBy=function(ec,hc=defaultComparator){const vdComparator=this.__hc;const td=GetComparatorFromKeySelector(ec,hc);const newComparator=(a,b)=>{const res=vdComparator(a,b);if(res!==0){return res}
return td(a,b)}
const xc=this;return new OrderedCollection(this.x(),newComparator)};OrderedCollection.prototype.ThenByDescending=function(ec,hc=defaultComparator){return this.ThenBy(ec,(a,b)=>hc(b,a))}
OrderedCollection.prototype.x=function(){const _xc=this;return function*(){yield* Reflect.construct(MinHeap,[[..._xc.iterable],_xc.__hc])}()}
return OrderedCollection})();function GetComparatorFromKeySelector(mc,hc=defaultComparator){if(n(mc)){return new Function('hc','ecFn','a','b',`return hc(ecFn(a),ecFn(b))`).bind(null,hc,mc)}else if(h(mc)){if(!(mc.startsWith('[')||mc.startsWith('.'))){mc=`.${mc}`}return new Function('hc','a','b',`return hc(a${mc},b${mc})`).bind(null,hc)}}
function Order(hc=defaultComparator){return this.OrderBy(x=>x,hc)}
function OrderDescending(hc=defaultComparator){return this.OrderByDescending(x=>x,hc)}
function OrderBy(ec,hc=defaultComparator){L(hc);return new OrderedCollection(this,GetComparatorFromKeySelector(ec,hc),MinHeap)}
function OrderByDescending(ec,hc=defaultComparator){return new OrderedCollection(this,GetComparatorFromKeySelector(ec,(a,b)=>hc(b,a)))}
function Shuffle(){return this.OrderBy(()=>Math.floor(Math.random()*3)-1 )}
function y(oc,key,dc){for(let yd of oc.keys()){if(dc(yd,key)){return yd}}
return key}
function GroupBy(ec,...bds){const arr=this.ToArray();function k(bd){let id=w(bd)===2;try{id=id&&bd(1,1)&&!bd(1,2)} catch(err){id=!1}
return id}
function u(ec){return v(ec,zc=>zc,undefined,A)}
function s(ec,qc){let dc,bc;if(k(qc)){dc=qc;bc=zc=>zc}else{dc=A;bc=qc}
return t(ec,bc,dc)}
function t(ec,qc,tc){let dc,bc,cc;if(k(tc)){dc=tc}else{cc=tc}
if(w(qc)===2){cc=qc}else{bc=qc}
if(!dc){dc=A}
if(!bc){bc=zc=>zc}
return v(ec,bc,cc,dc)}
function v(ec,bc,cc,dc){L(ec);L(bc);O(g(cc)||n(cc),'cc must be undefined or function!');L(dc);let oc=new Map();let id;for(let val of arr){const key=y(oc,ec(val),dc);const zc=bc(val);if(oc.has(key)){oc.get(key).push(zc)}else{oc.set(key,[zc])}}
if(cc){id=oc.ToArray().Select(g=>cc(...g))}else{id=oc}
return id}
let fn;switch(bds.length){case 0:;fn=u;break;case 1:;fn=s;break;case 2:;fn=t;break;case 3:;fn=v;break;default:;throw new Error('GroupBy uceter vc can not be greater than 4!')}
return fn(ec,...bds)}
function GroupJoin(qc,Z,Y,cc,X=A){J(qc);L(Z);L(Y);L(cc);let oc=new Map();const qd=this;for(let kd of qd.x()){const qdKey=Z(kd);oc.set(kd,new Collection(function*(){for(let qcVal of qc[Symbol.iterator]()){if(X(qdKey,Y(qcVal))){yield qcVal}}}))}
return new Collection(function*(){for(let [key,values] of oc){yield cc(key,values.ToArray())}})}
function SequenceEqual(pc,X=A){if(!l(pc)){return !1}
const sc=this.ToArray();pc=pc.ToArray();if(sc.length!==pc.length){return !1}
for(let i=0;i<sc.length;i++){let scVal=sc[i];let pcVal=pc[i];if(!X(scVal,pcVal)){return !1}}
return !0}D({defaultComparator,Min,Max,Average,Sum,Concat,Union,Join,Except,Zip,Intersect,Where,ConditionalWhere,Count,Contains,IndexOf,LastIndexOf,Any,All,ElementAt,Take,TakeWhile,TakeUntil,Skip,SkipWhile,SkipUntil,Contains,First,FirstOrDefault,Last,LastOrDefault,Single,SingleOrDefault,DefaultIfEmpty,MinHeap,Aggregate,Distinct,Select,SelectMany,Flatten,Reverse,ToArray,ToDictionary,ToJSON,ForEach,Add,Insert,Remove,Order,OrderBy,OrderDescending,OrderByDescending,Shuffle,GroupBy,GroupJoin,SequenceEqual });E(Collection.prototype,linqjsExports);OrderedCollection.prototype=E(E({},Collection.prototype),OrderedCollection.prototype);OrderedCollection.prototype.constructor=OrderedCollection;const protosToApplyWrappers=[window.Array.prototype,window.Set.prototype,window.Map.prototype];Object.keys(Collection.prototype).forEach(k=>{for(let proto of protosToApplyWrappers){proto[k]=function(...bds){return new Collection(this)[k](...bds)}}});return Collection}()))}());