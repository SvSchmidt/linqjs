/*!
 * linqjs v0.0.0
 * (c) Sven Schmidt 
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */
(function(){'use strict';
const window=this||(0,eval)('this');  const DEBUG=true;(function(Collection){try {if(typeof define==='function'&&define.amd){define(['require','exports'],function(){ return Collection })} else if(exports&&module&&module.exports){exports=module.exports=Collection}} catch(err){window.Collection=Collection}}(function(){let linqjsExports={}
let Collection;Collection=(function(){function Collection(iterableOrGenerator){qq(l(iterableOrGenerator)||m(iterableOrGenerator),'Parameter must be iterable or generator!');this.iterable=iterableOrGenerator}
Collection.prototype=(function(){function next(){if(!this.started){this.started=true;this.iterator=this.y()}
return this.iterator.next()}
function c(){this.started=false}
function y(){const iter=this.iterable;if(m(iter)){return iter()} else {return function *(){yield* iter}()}}return { next,c,y };}());Collection.prototype[Symbol.iterator]=function *(){let current;while(true){current=this.next();if(current.done){this.c();break}
yield current.value}}
return Collection}());function from(iterable){return new Collection(iterable)}
function Range(start,count){ii(count,0,Infinity);return new Collection(function *(){let i=start;while(i!=count+start){yield i++}})}
function Repeat(val,count){ii(count,0,Infinity);return new Collection(function *(){for(let i=0;i<count;i++){yield val}})}Object.defineProperty(Collection,'Empty',{get: function(){ return Collection.from([])}});const collectionStaticMethods={ from,From: from,Range,Repeat }
ff(Collection,collectionStaticMethods);function bb(first,second){return a(first)===a(second)}
function DefaultComparator(a,b){if(a<b){return -1;}
if(b<a){return 1;}
return 0;};
function qq(condition,msg){if(!condition){throw new Error(msg);}}
function nn(param){qq(n(param),'Parameter must be function!')}
function pp(param){qq(q(param),'Parameter must be array!')}
function jj(coll){qq(!o(coll),'Sequence is empty')}
function ll(obj){qq(l(obj),'Parameter must be iterable!')}
function oo(obj){qq(p(obj),'Pa>rameter must be collection!')}
function kk(collection){qq(!(collection.hasOwnProperty('StartedIterating')&&collection.StartedIterating()),'Iteration already started!')}
function gg(obj){qq(h(obj),'Parameter must be string!')}
function hh(obj){qq(i(obj),'Parameter must be numeric!')}function ii(num,min,max=Infinity){hh(num);qq(num>=min&&num<=max,`Number must be between ${min} and ${max}!`)}
function mm(coll,index){oo(coll);qq(i(index),'Index must be number!');qq(index>=0&&index<coll.Count(),'Index is out of bounds')}
function q(obj){return obj instanceof([]).constructor;}
function n(obj){return typeof obj==='function'}
function i(n){return !isNaN(parseFloat(n))}
function o(coll){if(p(coll)){return o(coll.Take(1).ToArray())}
return coll.length===0}
function l(obj){return(Symbol.iterator in Object(obj))}
function h(obj){return typeof obj==='string';}
function p(obj){return obj instanceof Collection}function m(obj){return obj instanceof(function *(){}).constructor;}
function g(obj){return typeof obj===typeof undefined}
function a(obj){return JSON.stringify(obj)}
function ff(target,source){Object.assign(Object(target),source);return target}
function ee(obj){ff(linqjsExports,obj)}
function f(param,value){return typeof param==='undefined'
? value
: param}
function dd(coll,seed,accumulator,resultTransformFn){nn(accumulator);nn(resultTransformFn);jj(coll);return resultTransformFn([seed].concat(coll).reduce(accumulator))}
function e(coll,equalityCompareFn=bb){ll(coll);nn(equalityCompareFn);const previous=[];return new Collection(function *(){const iter=coll.y();outer: for(let val of iter){inner: for(let prev of previous){if(equalityCompareFn(val,prev)){continue outer;}}
previous.push(val);yield val}})}
function d(arr,value){pp(arr);let elemsBefore=[];let elemFound=false;let current;while((current=arr.shift())&&!(elemFound=bb(current,value))){elemsBefore.push(current)}
arr.unshift(...elemsBefore);return elemFound}
const nativeConstructors=[Object,Number,Boolean,String,Symbol];function j(obj){return /native code/.test(Object(obj).toString())||!!~nativeConstructors.indexOf(obj)}
function aa(constructorOrValue=Object){if(constructorOrValue&&j(constructorOrValue)&&typeof constructorOrValue==='function'){let defaultValue=constructorOrValue();if(defaultValue instanceof Object||constructorOrValue===Date){return null} else {return defaultValue}}
return constructorOrValue}
function w(fn){nn(fn);return fn.length}
function Min(mapFn=x => x){nn(mapFn);jj(this);return Math.min.apply(null,this.Select(mapFn).ToArray())}
function Max(mapFn=x => x){nn(mapFn);jj(this);return Math.max.apply(null,this.Select(mapFn).ToArray())}
function Sum(){jj(this);return this.Aggregate(0,(prev,curr)=> prev+curr)}
function Average(){jj(this);return this.Sum()/ this.Count()}
function Concat(second){ll(second);const firstIter=this;if(!p(second)){second=new Collection(second)}
return new Collection(function *(){yield* firstIter;yield* second.y()})}
function Union(second,equalityCompareFn=bb){ll(second);return this.Concat(second).Distinct(equalityCompareFn)}
function Join(second,firstKeySelector,secondKeySelector,resultSelectorFn,keyEqualityCompareFn){ll(second);nn(firstKeySelector);nn(secondKeySelector);nn(resultSelectorFn);keyEqualityCompareFn=f(keyEqualityCompareFn,bb);nn(keyEqualityCompareFn);const firstIter=this;const result=new Collection(function *(){const secondIter=second.y();for(let firstValue of firstIter){const firstKey=firstKeySelector(firstValue);for(let secondValue of secondIter){const secondKey=secondKeySelector(secondValue);if(keyEqualityCompareFn(firstKey,secondKey)){yield resultSelectorFn(firstValue,secondValue)}}}});this.c();return result}
function Except(second){ll(second);const firstIter=this;const result=new Collection(function *(){for(let val of firstIter){if(!second.Contains(val)){yield val}}});this.c();second.c&&second.c();return result}
function Zip(second,resultSelectorFn){ll(second);nn(resultSelectorFn);const firstIter=this;const result=new Collection(function *(){const secondIter=second.y();for(let firstVal of firstIter){const secondNext=secondIter.next();if(secondNext.done){break}
yield resultSelectorFn(firstVal,secondNext.value)}});this.c();return result}
function Contains(elem){let result=false;for(let val of this){if(bb(elem,val)){result=true;break}}
this.c();return result}
function Where(predicate=(elem,index)=> true){nn(predicate);const iter=this.y();const result=new Collection(function *(){let index=0;for(let val of iter){if(predicate(val,index)){yield val}
index++}});return result}
function ConditionalWhere(condition,predicate){if(condition){return this.Where(predicate)} else {return this}}
function Count(predicate=elem => true){let count=0;
let filtered=this.Where(predicate);
while(!filtered.next().done){count++;}
return count;}
function Any(predicate){if(o(this)){return false}
if(!predicate){return true}
return !this.Where(predicate).next().done;}
function All(predicate=elem => true){nn(predicate);return !this.Any(x => !predicate(x))}
function ElementAt(index){mm(this,index);const result=this.Skip(index).Take(1).ToArray()[0];this.c();return result}
function Take(count=0){qq(i(count),'First parameter must be numeric!');if(count<=0){return Collection.Empty}
const iter=this.y();return new Collection(function *(){let i=0;for(let val of iter){yield val;if(++i===count){break}}})}
function Skip(count=0){qq(i(count),'First parameter must be numeric!');if(count<=0){return this}
const result=this.SkipWhile((elem,index)=> index<count);this.c();return result}
function TakeWhile(predicate=(elem,index)=> true){nn(predicate);const iter=this.y();const result=new Collection(function *(){let index=0;let endTake=false;for(let val of iter){if(!endTake&&predicate(val,index++)){yield val;continue}
endTake=true}});this.c();return result}
function TakeUntil(predicate=(elem,index)=> false){return this.TakeWhile((elem,index)=> !predicate(elem,index))}
function SkipWhile(predicate=(elem,index)=> true){nn(predicate);const iter=this.y();return new Collection(function *(){let index=0;let endSkip=false;for(let val of iter){if(!endSkip&&predicate(val,index++)){continue}
endSkip=true;yield val}})}
function SkipUntil(predicate=(elem,index)=> false){return this.SkipWhile((elem,index)=> !predicate(elem,index))}
function b(collection,originalFn,predicateOrConstructor=x => true,constructor=Object){let predicate;if(j(predicateOrConstructor)){predicate=x => true;constructor=predicateOrConstructor} else {predicate=predicateOrConstructor}
nn(predicate);qq(j(constructor),'constructor must be native constructor,e.g. Number!');const defaultVal=aa(constructor);if(o(collection)){return defaultVal}
return originalFn.call(collection,predicate)}
function First(predicate=x => true){nn(predicate);jj(this);const result=this.SkipWhile(elem => !predicate(elem)).Take(1).ToArray()[0];this.c();return result}
function FirstOrDefault(predicateOrConstructor=x => true,constructor=Object){return b(this,First,predicateOrConstructor,constructor)}
function Last(predicate=x => true){nn(predicate);jj(this);return this.Reverse().First(predicate)}
function LastOrDefault(predicateOrConstructor=x => true,constructor=Object){return b(this,Last,predicateOrConstructor,constructor)}
function Single(predicate=x => true){nn(predicate);jj(this);let index=0;let result;for(let val of this.y()){if(predicate(val)){result=val;break}
index++}
if(this.First(elem => predicate(elem)&&!bb(elem,result))){throw new Error('Sequence contains more than one element')}
return result}
function SingleOrDefault(predicateOrConstructor=x => true,constructor=Object){return b(this,Single,predicateOrConstructor,constructor)}
function DefaultIfEmpty(constructorOrValue){if(!o(this)){return this}
return [aa(constructorOrValue)]}
let HeapElement=(function(){function HeapElement(index,value){this.__index=index;
this.__value=value;
this.__isHeapElementInstance=true;}
HeapElement.CreateHeapElement=function CreateHeapElement(index,obj){if(obj===undefined||obj.__isHeapElementInstance){return obj;}
return new HeapElement(index,obj);};
return HeapElement;})();
let MinHeap=(function(){function MinHeap(elements,comparator=DefaultComparator){pp(elements);
nn(comparator);
this.elements=elements;
this.comparator=(a,b)=> {let res=comparator(a.__value,b.__value);
if(res!==0){return res;}
return DefaultComparator(a.__index,b.__index);};
cc(this.elements,this.comparator);}
function r(elements,comparator,i){let right    =2 *(i+1);
let left     =right-1;
let bestIndex=i;
elements[bestIndex]=HeapElement.CreateHeapElement(bestIndex,elements[bestIndex]);
if(left<elements.length){elements[left]=HeapElement.CreateHeapElement(left,elements[left]);
if(comparator(elements[left],elements[bestIndex])<0){bestIndex=left;}}
if(right<elements.length){elements[right]=HeapElement.CreateHeapElement(right,elements[right]);
if(comparator(elements[right],elements[bestIndex])<0){bestIndex=right;}}
if(bestIndex!==i){let tmp=elements[i];
elements[i]=elements[bestIndex];
elements[bestIndex]=tmp;
r(elements,comparator,bestIndex);}}
function cc(elements,comparator){if(elements.length===0){return;}
for(let i=Math.floor(elements.length / 2);i>=0;i--){r(elements,comparator,i);}}
MinHeap.prototype.hasTopElement=function(){return this.elements.length>0;};
MinHeap.prototype.getTopElement=function(){if(this.elements.length===1){return this.elements.pop().__value;}
let topElement=this.elements[0];
let tmp=this.elements.pop();
this.elements[0]=tmp;
r(this.elements,this.comparator,0);
return topElement.__value;};
MinHeap.prototype[Symbol.iterator]=function(){let heap=this;
return {next: function(){if(heap.hasTopElement()){return {done:  false,
value: heap.getTopElement()};}
return {done: true};}}};
return MinHeap;})();
let MaxHeap=(function(){function MaxHeap(elements,comparator=DefaultComparator){pp(elements);
nn(comparator);MinHeap.apply(this,[elements,function(a,b){ return -1 * comparator(a,b);}]);}
MaxHeap.prototype=Object.create(MinHeap.prototype);
MaxHeap.prototype.constructor=MaxHeap;
return MaxHeap;})();function Aggregate(seedOrAccumulator,accumulator,resultTransformFn){const values=this.ToArray();if(typeof seedOrAccumulator==='function'&&!accumulator&&!resultTransformFn){return dd(values.slice(1,values.length),values.slice(0,1)[0],seedOrAccumulator,elem => elem)} else if(typeof seedOrAccumulator!=='function'&&typeof accumulator==='function'&&!resultTransformFn){return dd(values,seedOrAccumulator,accumulator,elem => elem)} else {return dd(values,seedOrAccumulator,accumulator,resultTransformFn)}}
function Select(mapFn=x => x){const iter=this.y();return new Collection(function *(){for(let val of iter){yield mapFn(val)}})}
function Flatten(){return this.SelectMany(x => x)}
function SelectMany(mapFn,resultSelector=(x,y)=> y){nn(mapFn);nn(resultSelector);const iter=this.y();return new Collection(function *(){let index=0;for(let current of iter){let mappedEntry=mapFn(current,index);let newIter=mappedEntry;if(!l(mappedEntry)){newIter=[mappedEntry]} else {newIter=mappedEntry}
for(let val of newIter[Symbol.iterator]()){yield resultSelector(current,val)}
index++}})}
function Distinct(equalityCompareFn=bb){nn(equalityCompareFn);return e(this,equalityCompareFn)}
function ToArray(){return [...this.y()]}
function ToDictionary(keySelector,elementSelectorOrKeyComparer,keyComparer){nn(keySelector);if(!elementSelectorOrKeyComparer&&!keyComparer){return this.ToDictionary(keySelector,elem => elem,bb)} else if(!keyComparer&&w(elementSelectorOrKeyComparer)===1){return this.ToDictionary(keySelector,elementSelectorOrKeyComparer,bb)} else if(!keyComparer&&w(elementSelectorOrKeyComparer)===2){return this.ToDictionary(keySelector,elem => elem,elementSelectorOrKeyComparer)}nn(keyComparer);nn(elementSelectorOrKeyComparer);let usedKeys=[];let result=new Map();const input=this.ToArray();const elementSelector=elementSelectorOrKeyComparer;for(let value of input){let key=keySelector(value);let elem=elementSelector(value);qq(key!=null,'Key is not allowed to be null!');qq(!usedKeys.Any(x => keyComparer(x,key)),`Key '${key}' is already in use!`);usedKeys.push(key);result.set(key,elem)}
return result}
function ToJSON(){return a(this.ToArray())}
function Reverse(){const arr=this.ToArray();return new Collection(function *(){for(let i=arr.length-1;i>=0;i--){yield arr[i]}})}
function ForEach(fn){nn(fn);for(let val of this.y()){fn(val)}}
function Add(value){this.Insert(value,this.Count())}
function Insert(value,index){qq(index>=0&&index<=this.Count(),'Index is out of bounds!');const oldIter=this.ToArray();this.iterable=function *(){yield* oldIter.slice(0,index);yield value;yield* oldIter.slice(index,oldIter.length)}
this.c()}
function Remove(value){let values=this.ToArray();const result=d(values,value);if(!result){return false}
this.iterable=function *(){yield* values}
this.c();return true}
let OrderedLinqCollection=(function(){function OrderedLinqCollection(iterable,comparator,heapConstructor){ll(iterable);
nn(comparator);
nn(heapConstructor);
Collection.apply(this,[iterable]);
this.__comparator     =comparator;
this.__heapConstructor=heapConstructor;}
OrderedLinqCollection.prototype.ThenBy=function ThenBy(additionalComparator){kk(this);
if(h(additionalComparator)){additionalComparator=GetComparatorFromKeySelector(additionalComparator);}
nn(additionalComparator);
let currentComparator=this.__comparator;
this.__comparator=(a,b)=> {let res=currentComparator(a,b);
if(res!==0){return res;}
return additionalComparator(a,b);};
return this;};
OrderedLinqCollection.prototype.y=function(){const _self=this;return function *(){yield* Reflect.construct(_self.__heapConstructor,[[..._self.iterable],_self.__comparator])}()}
return OrderedLinqCollection;})();
function GetComparatorFromKeySelector(selector){gg(selector);
if(selector===''){return Collection.prototype.DefaultComparator;}if(!(selector.startsWith('[')||selector.startsWith('.'))){selector=`.${selector}`;}
let result;eval(`result=function(a,b){ return Collection.prototype.DefaultComparator(a${selector},b${selector})}`);
return result;}
function Order(){return this.OrderBy(DefaultComparator);}
function OrderDescending(){return this.OrderByDescending(DefaultComparator);}
function OrderBy(comparator){if(h(comparator)){comparator=GetComparatorFromKeySelector(comparator);}
nn(comparator);
return new OrderedLinqCollection(this,comparator,MinHeap);};
function OrderByDescending(comparator){if(h(comparator)){comparator=GetComparatorFromKeySelector(comparator);}
nn(comparator);
return new OrderedLinqCollection(this,comparator,MaxHeap);};
function Shuffle(){return this.OrderBy(()=> Math.floor(Math.random()* 3)-1 )}
function GroupBy(keySelector,...args){const arr=this.ToArray();function k(arg){let result=w(arg)===2;try {result=result&&arg(1,1)&&!arg(1,2)} catch(err){result=false}
return result}
function x(groups,key,keyComparer){for(let groupKey of groups.keys()){if(keyComparer(groupKey,key)){return groupKey}}
return key}
function u(keySelector){return v(keySelector,elem => elem,undefined,bb)}
function s(keySelector,second){let keyComparer,elementSelector;if(k(second)){keyComparer=second;elementSelector=elem => elem} else {keyComparer=bb;elementSelector=second}
return t(keySelector,elementSelector,keyComparer)}
function t(keySelector,second,third){let keyComparer,elementSelector,resultSelector;if(k(third)){keyComparer=third} else {resultSelector=third}
if(w(second)===2){resultSelector=second} else {elementSelector=second}
if(!keyComparer){keyComparer=bb}
if(!elementSelector){elementSelector=elem => elem}
return v(keySelector,elementSelector,resultSelector,keyComparer)}
function v(keySelector,elementSelector,resultSelector,keyComparer){nn(keySelector);nn(elementSelector);qq(g(resultSelector)||n(resultSelector),'resultSelector must be undefined or function!');nn(keyComparer);let groups=new Map();let result;for(let val of arr){const key=x(groups,keySelector(val),keyComparer);const elem=elementSelector(val);if(groups.has(key)){groups.get(key).push(elem)} else {groups.set(key,[elem])}}
if(resultSelector){result=groups.ToArray().Select(g => resultSelector(...g))} else {result=groups}
return result}
let fn;switch(args.length){case 0:;fn=u;break;case 1:;fn=s;break;case 2:;fn=t;break;case 3:;fn=v;break;default:;throw new Error('GroupBy parameter count can not be greater than 4!')}
return fn(keySelector,...args)}
function SequenceEqual(second,equalityCompareFn=bb){if(!l(second)){return false}
const first=this.ToArray();second=second.ToArray();if(first.length!==second.length){return false}
for(let i=0;i<first.length;i++){let firstVal=first[i];let secondVal=second[i];if(!equalityCompareFn(firstVal,secondVal)){return false}}
return true}ee({ DefaultComparator,Min,Max,Average,Sum,Concat,Union,Join,Except,Zip,Where,ConditionalWhere,Count,Any,All,ElementAt,Take,TakeWhile,TakeUntil,Skip,SkipWhile,SkipUntil,Contains,First,FirstOrDefault,Last,LastOrDefault,Single,SingleOrDefault,DefaultIfEmpty,DefaultComparator,MinHeap,MaxHeap,Aggregate,Distinct,Select,SelectMany,Flatten,Reverse,ToArray,ToDictionary,ToJSON,ForEach,Add,Insert,Remove,GetComparatorFromKeySelector,OrderedLinqCollection,Order,OrderBy,OrderDescending,OrderByDescending,Shuffle,GroupBy,SequenceEqual });ff(Collection.prototype,linqjsExports);OrderedLinqCollection.prototype=ff(ff({},Collection.prototype),OrderedLinqCollection.prototype);
OrderedLinqCollection.prototype.constructor=OrderedLinqCollection;
const protosToApplyWrappers=[window.Array.prototype,window.Set.prototype,window.Map.prototype];Object.keys(Collection.prototype).forEach(k => {for(let proto of protosToApplyWrappers){proto[k]=function(...args){return new Collection(this)[k](...args)}}});return Collection}()))}());