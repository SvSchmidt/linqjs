/*!
 * linqjs v0.0.0
 * (c) Sven Schmidt 
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */
(function(){'use strict';const window=this||(0,eval)('this');const DEBUG=!0;(function(Collection){try{if(typeof define==='function'&&define.amd){define(['require','exports'],function(){return Collection })}else if(exports&&module&&module.exports){exports=module.exports=Collection}} catch(err){window.Collection=Collection}}(function(){let linqjsExports={}
let Collection=(function(){function Collection(S){O(l(S)||m(S),'Parameter must be iterable or generator!');this.iterable=S}
Collection.prototype=(function(){function next(){if(!this.started){this.started=!0;this.iterator=this.x()}
return this.iterator.next()}
function c(){this.started=!1}
function x(){const iter=this.iterable;if(m(iter)){return iter()}else{return function*(){yield* iter}()}}return{next,c,x }}());Collection.prototype[Symbol.iterator]=function*(){let td;while(!0){td=this.next();if(td.done){this.c();break}
yield td.value}}
return Collection}());function From(iterable){return new Collection(iterable)}
function Range(start,tc){H(tc,0,1/0);return new Collection(function*(){let i=start;while(i!=tc+start){yield i++}})}
function Repeat(val,tc){H(tc,0,1/0);return new Collection(function*(){for(let i=0;i<tc;i++){yield val}})}Object.defineProperty(Collection,'Empty',{get:function(){return Collection.from([])}});const pd={From,from:From,Range,Repeat }
E(Collection,pd);function A(wc,qc){return a(wc)===a(qc)}
function defaultComparator(a,b){if(a<b){return -1}
if(b<a){return 1}
return 0}class AssertionError extends Error{constructor(expected,got){super(`Expected ${expected},got ${got}!`)}}
function O(kc,...bds){if(!kc){if(bds.length===1){throw new Error(msg)}else if(bds.length===2){throw new AssertionError(...bds)}}}
function L(rc){O(n(rc),'function',rc)}
function N(rc){O(q(rc),'array',rc)}
function I(xc){O(!o(xc),'Sequence is empty!')}
function J(ac){O(l(ac),'iterable',ac)}
function M(ac){O(p(ac),'collection',ac)}
function F(ac){O(h(ac),'string',ac)}
function G(ac){O(i(ac),'numeric value',ac)}function H(num,min,max=1/0){G(num);O(num>=min&&num<=max,`Number must be between ${min} and ${max}!`)}
function K(xc,index){M(xc);O(i(index),'number',index);O(index>=0&&index<xc.Count(),'Index is out of bounds')}
function q(ac){return ac instanceof([]).constructor}
function n(ac){return typeof ac==='function'}
function i(n){return !isNaN(parseFloat(n))}
function o(coll){if(p(coll)){return o(coll.Take(1).ToArray())}
return coll.length===0}
function l(ac){return(Symbol.iterator in Object(ac))}
function h(ac){return typeof ac==='string'}
function p(ac){return ac instanceof Collection}function m(ac){return ac instanceof(function*(){}).constructor}
function g(ac){return typeof ac===typeof undefined}
function a(ac){return JSON.stringify(ac)}
function E(tbdet,source){Object.assign(Object(tbdet),source);return tbdet}
function D(ac){E(linqjsExports,ac)}
function f(rc,value){return typeof rc==='undefined'?value:rc}
function C(coll,yc,ec,X){L(ec);L(X);I(coll);return X([yc].concat(coll).reduce(ec))}
function e(coll,W=A){J(coll);L(W);const jd=[];return new Collection(function*(){const iter=coll.x();qd:for(let val of iter){uc:for(let prev of jd){if(W(val,prev)){continue qd}}
jd.push(val);yield val}})}
function d(arr,value){N(arr);let zcsBefore=[];let zcFound=!1;let td;while((td=arr.shift())&&!(zcFound=A(td,value))){zcsBefore.push(td)}
arr.unshift(...zcsBefore);return zcFound}
const cd=[Object,Number,Boolean,String,Symbol];function j(ac){return /native code/.test(Object(ac).toString())||!!~cd.indexOf(ac)}
function z(U=Object){if(U&&j(U)&&typeof U==='function'){let hdue=U();if(hdue instanceof Object||U===Date){return null}else{return hdue}}
return U}
function w(fn){L(fn);return fn.length}
function Min(vc=x=>x){L(vc);I(this);return Math.min.apply(null,this.Select(vc).ToArray())}
function Max(vc=x=>x){L(vc);I(this);return Math.max.apply(null,this.Select(vc).ToArray())}
function Sum(vc=x=>x){I(this);return this.Select(vc).Aggregate(0,(prev,curr)=>prev+curr)}
function Average(vc=x=>x){I(this);return this.Sum(vc)/ this.Count()}
function Concat(uc){J(uc);const qd=this;return new Collection(function*(){yield* qd.x();yield* uc})}
function Union(uc,W=A){J(uc);return this.Concat(uc).Distinct(W)}
function Join(uc,aa,Z,Y,R){J(uc);L(aa);L(Z);L(Y);R=f(R,A);L(R);const qd=this;return new Collection(function*(){for(let dd of qd.x()){const qdKey=aa(dd);for(let ucValue of uc[Symbol.iterator]()){const ucKey=Z(ucValue);if(R(qdKey,ucKey)){yield Y(dd,ucValue)}}}})}
function Except(uc){J(uc);if(!p(uc)){uc=new Collection(uc)}
const qd=this;return new Collection(function*(){for(let val of qd.x()){if(!uc.Contains(val)){yield val}}})}
function Zip(uc,Y){J(uc);L(Y);const qd=this;return new Collection(function*(){const ucIter=uc[Symbol.iterator]();for(let kd of qd.x()){const ucNext=ucIter.next();if(ucNext.done){break}
yield Y(kd,ucNext.value)}})}
function Intersect(uc,W=A){J(uc);L(W);const qdIter=this.ToArray();return new Collection(function*(){const ucIter=[...uc];for(let val of qdIter){if(ucIter.Any(zc=>W(val,zc))){yield val}}})}
function IndexOf(oc,W=A){L(W);const iter=this.x();let i=0;for(let val of iter){if(W(val,oc)){return i}
i++}
return -1}
function LastIndexOf(oc,W=A){L(W);const iter=this.x();let i=0;let od=-1;for(let val of iter){if(W(val,oc)){od=i}
i++}
return od}
function Contains(zc,W=A){return !!~this.IndexOf(zc,W)}
function Where(jc=(zc,index)=>!0){L(jc);const iter=this.x();const id=new Collection(function*(){let index=0;for(let val of iter){if(jc(val,index)){yield val}
index++}});return id}
function ConditionalWhere(kc,jc){if(kc){return this.Where(jc)}else{return this}}
function Count(jc=zc=>!0){let tc=0;let filtered=this.Where(jc);while(!filtered.next().done){tc++}
return tc}
function Any(jc){if(o(this)){return !1}
if(!jc){return !0}
return !this.Where(jc).next().done}
function All(jc=zc=>!0){L(jc);return !this.Any(x=>!jc(x))}
function b(xc,hc,T=x=>!0,nc=Object){let jc;if(j(T)||!n(T)){jc=x=>!0;nc=T}else{jc=T}
L(jc);const hd=z(nc);if(o(xc)){return hd}
let id=hc.call(xc,jc);if(!id){return hd}
return id}
function ElementAt(index){K(this,index);const id=this.Skip(index).Take(1).ToArray()[0];this.c();return id}
function Take(tc=0){G(tc);if(tc<=0){return Collection.Empty}
const iter=this.x();return new Collection(function*(){let i=0;for(let val of iter){yield val;if(++i===tc){break}}})}
function Skip(tc=0){G(tc);if(tc<=0){return this}
return this.SkipWhile((zc,index)=>index<tc)}
function TakeWhile(jc=(zc,index)=>!0){L(jc);const _xc=this;const id=new Collection(function*(){let index=0;let endTake=!1;for(let val of _xc.x()){if(!endTake&&jc(val,index++)){yield val;continue}
endTake=!0}});this.c();return id}
function TakeUntil(jc=(zc,index)=>!1){return this.TakeWhile((zc,index)=>!jc(zc,index))}
function SkipWhile(jc=(zc,index)=>!0){L(jc);const _xc=this;return new Collection(function*(){let index=0;let xd=!1;for(let val of _xc.x()){if(!xd&&jc(val,index++)){continue}
xd=!0;yield val}})}
function SkipUntil(jc=(zc,index)=>!1){return this.SkipWhile((zc,index)=>!jc(zc,index))}
function First(jc=x=>!0){L(jc);I(this);const id=this.SkipWhile(zc=>!jc(zc)).Take(1).ToArray()[0];this.c();return id}
function FirstOrDefault(Q=x=>!0,constructor=Object){return b(this,First,Q,constructor)}
function Last(jc=x=>!0){L(jc);I(this);return this.Reverse().First(jc)}
function LastOrDefault(Q=x=>!0,constructor=Object){return b(this,Last,Q,constructor)}
function Single(jc=x=>!0){L(jc);I(this);let index=0;let id;for(let val of this.x()){if(jc(val)){id=val;break}
index++}
if(this.First(zc=>jc(zc)&&!A(zc,id))){throw new Error('Sequence contains more than one oc')}
return id}
function SingleOrDefault(Q=x=>!0,constructor=Object){return b(this,Single,Q,constructor)}
function DefaultIfEmpty(U){if(!o(this)){return this}
return [z(U)]}
let yd=(function(){function yd(index,value){this.__index=index;this.__value=value;this.__isydInstance=!0}
yd.Createyd=function(index,ac){if(ac===undefined||ac.__isydInstance){return ac}
return new yd(index,ac)};return yd})();let MinHeap=(function(){function MinHeap(lc,ic=defaultComparator){N(lc);L(ic);this.lc=lc;this.ic=(a,b)=>{let res=ic(a.__value,b.__value);if(res!==0){return res}
return defaultComparator(a.__index,b.__index)};B(this.lc,this.ic)}
function r(lc,ic,i){let right=2*(i+1);let left=right-1;let bestIndex=i;lc[bestIndex]=yd.Createyd(bestIndex,lc[bestIndex]);if(left<lc.length){lc[left]=yd.Createyd(left,lc[left]);if(ic(lc[left],lc[bestIndex])<0){bestIndex=left}}
if(right<lc.length){lc[right]=yd.Createyd(right,lc[right]);if(ic(lc[right],lc[bestIndex])<0){bestIndex=right}}
if(bestIndex!==i){let tmp=lc[i];lc[i]=lc[bestIndex];lc[bestIndex]=tmp;r(lc,ic,bestIndex)}}
function B(lc,ic){if(lc.length===0){return}
for(let i=Math.floor(lc.length / 2);i>=0;i--){r(lc,ic,i)}}
MinHeap.prototype.zd=function(){return this.lc.length>0};MinHeap.prototype.getTopElement=function(){if(this.lc.length===1){return this.lc.pop().__value}
let topElement=this.lc[0];let tmp=this.lc.pop();this.lc[0]=tmp;r(this.lc,this.ic,0);return topElement.__value};MinHeap.prototype[Symbol.iterator]=function(){let heap=this;return{next:function(){if(heap.zd()){return{done:!1,
value:heap.getTopElement()}}
return{done:!0}}}};return MinHeap})();let MaxHeap=(function(){function MaxHeap(lc,ic=defaultComparator){N(lc);L(ic);MinHeap.apply(this,[lc,function(a,b){return -1*ic(a,b)}])}
MaxHeap.prototype=Object.create(MinHeap.prototype);MaxHeap.prototype.constructor=MaxHeap;return MaxHeap})();function Aggregate(V,ec,X){const values=this.ToArray();if(typeof V==='function'&&!ec&&!X){return C(values.slice(1,values.length),values.slice(0,1)[0],V,zc=>zc)}else if(typeof V!=='function'&&typeof ec==='function'&&!X){return C(values,V,ec,zc=>zc)}else{return C(values,V,ec,X)}}
function Select(vc=x=>x){const iter=this.x();let index=0;return new Collection(function*(){for(let val of iter){yield vc(val,index);index ++}})}
function Flatten(){return this.SelectMany(x=>x)}
function SelectMany(vc,dc=(x,y)=>y){L(vc);L(dc);const iter=this.x();return new Collection(function*(){let index=0;for(let td of iter){let sd=vc(td,index);let newIter=sd;if(!l(sd)){newIter=[sd]}else{newIter=sd}
for(let val of newIter[Symbol.iterator]()){yield dc(td,val)}
index++}})}
function Distinct(W=A){L(W);return e(this,W)}
function ToArray(){return [...this.x()]}
function ToDictionary(gc,P,fc){L(gc);if(!P&&!fc){return this.ToDictionary(gc,zc=>zc,A)}else if(!fc&&w(P)===1){return this.ToDictionary(gc,P,A)}else if(!fc&&w(P)===2){return this.ToDictionary(gc,zc=>zc,P)}L(fc);L(P);let usedKeys=[];let id=new Map();const input=this.ToArray();const cc=P;for(let value of input){let key=gc(value);let zc=cc(value);O(key!=null,'Key is not allowed to be null!');O(!usedKeys.Any(x=>fc(x,key)),`Key '${key}' is already in use!`);usedKeys.push(key);id.set(key,zc)}
return id}
function ToJSON(){return a(this.ToArray())}
function Reverse(){const arr=this.ToArray();return new Collection(function*(){for(let i=arr.length-1;i>=0;i--){yield arr[i]}})}
function ForEach(fn){L(fn);for(let val of this.x()){fn(val)}}
function Add(value){this.Insert(value,this.Count())}
function Insert(value,index){O(index>=0&&index<=this.Count(),'Index is out of bounds!');const oldIter=this.ToArray();this.iterable=function*(){yield* oldIter.slice(0,index);yield value;yield* oldIter.slice(index,oldIter.length)}}
function Remove(value){let values=this.ToArray();const id=d(values,value);if(!id){return !1}
this.iterable=function*(){yield* values}
return !0}
let OrderedCollection=(function(){function OrderedCollection(iterable,ic,bc){J(iterable);L(ic);L(bc);Collection.apply(this,[iterable]);this.__ic=ic;this.__bc=bc}
OrderedCollection.prototype.ThenBy=function(rd){if(h(rd)){rd=GetComparatorFromKeySelector(rd)}
L(rd);let tdComparator=this.__ic;this.__ic=(a,b)=>{let res=tdComparator(a,b);if(res!==0){return res}
return rd(a,b)};return this};OrderedCollection.prototype.x=function(){const _xc=this;return function*(){yield* Reflect.construct(_xc.__bc,[[..._xc.iterable],_xc.__ic])}()}
return OrderedCollection})();function GetComparatorFromKeySelector(mc){F(mc);if(mc===''){return defaultComparator}if(!(mc.startsWith('[')||mc.startsWith('.'))){mc=`.${mc}`}return new Function('ic','a','b',`return ic(a${mc},b${mc})`).bind(null,defaultComparator)}
function Order(){return this.OrderBy(defaultComparator)}
function OrderDescending(){return this.OrderByDescending(defaultComparator)}
function OrderBy(ic){if(h(ic)){ic=GetComparatorFromKeySelector(ic)}
L(ic);return new OrderedCollection(this,ic,MinHeap)};function OrderByDescending(ic){if(h(ic)){ic=GetComparatorFromKeySelector(ic)}
L(ic);return new OrderedCollection(this,ic,MaxHeap)};function Shuffle(){return this.OrderBy(()=>Math.floor(Math.random()*3)-1 )}
function y(pc,key,fc){for(let wd of pc.keys()){if(fc(wd,key)){return wd}}
return key}
function GroupBy(gc,...bds){const arr=this.ToArray();function k(bd){let id=w(bd)===2;try{id=id&&bd(1,1)&&!bd(1,2)} catch(err){id=!1}
return id}
function u(gc){return v(gc,zc=>zc,undefined,A)}
function s(gc,uc){let fc,cc;if(k(uc)){fc=uc;cc=zc=>zc}else{fc=A;cc=uc}
return t(gc,cc,fc)}
function t(gc,uc,sc){let fc,cc,dc;if(k(sc)){fc=sc}else{dc=sc}
if(w(uc)===2){dc=uc}else{cc=uc}
if(!fc){fc=A}
if(!cc){cc=zc=>zc}
return v(gc,cc,dc,fc)}
function v(gc,cc,dc,fc){L(gc);L(cc);O(g(dc)||n(dc),'dc must be undefined or function!');L(fc);let pc=new Map();let id;for(let val of arr){const key=y(pc,gc(val),fc);const zc=cc(val);if(pc.has(key)){pc.get(key).push(zc)}else{pc.set(key,[zc])}}
if(dc){id=pc.ToArray().Select(g=>dc(...g))}else{id=pc}
return id}
let fn;switch(bds.length){case 0:;fn=u;break;case 1:;fn=s;break;case 2:;fn=t;break;case 3:;fn=v;break;default:;throw new Error('GroupBy rceter tc can not be greater than 4!')}
return fn(gc,...bds)}
function GroupJoin(uc,aa,Z,dc,W=A){J(uc);L(aa);L(Z);L(dc);let pc=new Map();const qd=this;for(let kd of qd.x()){const qdKey=aa(kd);pc.set(kd,new Collection(function*(){for(let ucVal of uc[Symbol.iterator]()){if(W(qdKey,Z(ucVal))){yield ucVal}}}))}
return new Collection(function*(){for(let [key,values] of pc){yield dc(key,values.ToArray())}})}
function SequenceEqual(qc,W=A){if(!l(qc)){return !1}
const wc=this.ToArray();qc=qc.ToArray();if(wc.length!==qc.length){return !1}
for(let i=0;i<wc.length;i++){let wcVal=wc[i];let qcVal=qc[i];if(!W(wcVal,qcVal)){return !1}}
return !0}D({defaultComparator,Min,Max,Average,Sum,Concat,Union,Join,Except,Zip,Intersect,Where,ConditionalWhere,Count,Contains,IndexOf,LastIndexOf,Any,All,ElementAt,Take,TakeWhile,TakeUntil,Skip,SkipWhile,SkipUntil,Contains,First,FirstOrDefault,Last,LastOrDefault,Single,SingleOrDefault,DefaultIfEmpty,MinHeap,MaxHeap,Aggregate,Distinct,Select,SelectMany,Flatten,Reverse,ToArray,ToDictionary,ToJSON,ForEach,Add,Insert,Remove,GetComparatorFromKeySelector,OrderedCollection,Order,OrderBy,OrderDescending,OrderByDescending,Shuffle,GroupBy,GroupJoin,SequenceEqual });E(Collection.prototype,linqjsExports);OrderedCollection.prototype=E(E({},Collection.prototype),OrderedCollection.prototype);OrderedCollection.prototype.constructor=OrderedCollection;const protosToApplyWrappers=[window.Array.prototype,window.Set.prototype,window.Map.prototype];Object.keys(Collection.prototype).forEach(k=>{for(let proto of protosToApplyWrappers){proto[k]=function(...bds){return new Collection(this)[k](...bds)}}});return Collection}()))}());