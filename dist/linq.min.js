/*!
 * linqjs v0.0.0
 * (c) Sven Schmidt 
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */
(function(){'use strict';
const window=this||(0,eval)('this');  const DEBUG=!0;(function(Collection){try{if(typeof define==='function'&&define.amd){define(['require','exports'],function(){return Collection })} else if(exports&&module&&module.exports){exports=module.exports=Collection}} catch(err){window.Collection=Collection}}(function(){let linqjsExports={}
let Collection;Collection=(function(){function Collection(V){O(l(V)||m(V),'Parameter must be iterable or generator!');this.iterable=V}
Collection.prototype=(function(){function next(){if(!this.started){this.started=!0;this.iterator=this.y()}
return this.iterator.next()}
function c(){this.started=!1}
function y(){const iter=this.iterable;if(m(iter)){return iter()} else{return function*(){yield* iter}()}}return{next,c,y };}());Collection.prototype[Symbol.iterator]=function*(){let current;while(!0){current=this.next();if(current.done){this.c();break}
yield current.value}}
return Collection}());function from(iterable){return new Collection(iterable)}
function Range(start,count){H(count,0,Infinity);return new Collection(function*(){let i=start;while(i!=count+start){yield i++}})}
function Repeat(val,count){H(count,0,Infinity);return new Collection(function*(){for(let i=0;i<count;i++){yield val}})}Object.defineProperty(Collection,'Empty',{get:function(){return Collection.from([])}});const dc={from,From:from,Range,Repeat }
E(Collection,dc);function A(ec,fc){return a(ec)===a(fc)}
function DefaultComparator(a,b){if(a<b){return -1;}
if(b<a){return 1;}
return 0;};class AssertionError extends Error{constructor(expected,got){super(`Expected ${expected},got ${got}!`)}}
function O(hc,...args){if(!hc){if(args.length===1){throw new Error(msg);} else if(args.length===2){throw new AssertionError(...args)}}}
function L(jc){O(n(jc),'function',jc)}
function N(jc){O(q(jc),'array',jc)}
function I(coll){O(!o(coll),'Sequence is empty!')}
function J(obj){O(l(obj),'iterable',obj)}
function M(obj){O(p(obj),'collection',obj)}
function F(obj){O(h(obj),'string',obj)}
function G(obj){O(i(obj),'numeric value',obj)}function H(num,min,max=Infinity){G(num);O(num>=min&&num<=max,`Number must be between ${min} and ${max}!`)}
function K(coll,index){M(coll);O(i(index),'number',index);O(index>=0&&index<coll.Count(),'Index is out of bounds')}
function q(obj){return obj instanceof([]).constructor;}
function n(obj){return typeof obj==='function'}
function i(n){return !isNaN(parseFloat(n))}
function o(coll){if(p(coll)){return o(coll.Take(1).ToArray())}
return coll.length===0}
function l(obj){return(Symbol.iterator in Object(obj))}
function h(obj){return typeof obj==='string';}
function p(obj){return obj instanceof Collection}function m(obj){return obj instanceof(function*(){}).constructor;}
function g(obj){return typeof obj===typeof undefined}
function a(obj){return JSON.stringify(obj)}
function E(target,source){Object.assign(Object(target),source);return target}
function D(obj){E(linqjsExports,obj)}
function f(jc,value){return typeof jc==='undefined'?value:jc}
function C(coll,seed,accumulator,Q){L(accumulator);L(Q);I(coll);return Q([seed].concat(coll).reduce(accumulator))}
function e(coll,R=A){J(coll);L(R);const previous=[];return new Collection(function*(){const iter=coll.y();outer:for(let val of iter){inner:for(let prev of previous){if(R(val,prev)){continue outer;}}
previous.push(val);yield val}})}
function d(arr,value){N(arr);let icsBefore=[];let icFound=!1;let current;while((current=arr.shift())&&!(icFound=A(current,value))){icsBefore.push(current)}
arr.unshift(...icsBefore);return icFound}
const aa=[Object,Number,Boolean,String,Symbol];function j(obj){return /native code/.test(Object(obj).toString())||!!~aa.indexOf(obj)}
function z(W=Object){if(W&&j(W)&&typeof W==='function'){let defaultValue=W();if(defaultValue instanceof Object||W===Date){return null} else{return defaultValue}}
return W}
function w(fn){L(fn);return fn.length}
function Min(mapFn=x=>x){L(mapFn);I(this);return Math.min.apply(null,this.Select(mapFn).ToArray())}
function Max(mapFn=x=>x){L(mapFn);I(this);return Math.max.apply(null,this.Select(mapFn).ToArray())}
function Sum(mapFn=x=>x){I(this);return this.Select(mapFn).Aggregate(0,(prev,curr)=>prev+curr)}
function Average(mapFn=x=>x){I(this);return this.Sum(mapFn)/ this.Count()}
function Concat(fc){J(fc);const bc=this.y();return new Collection(function*(){yield* bc;yield* fc})}
function Union(fc,R=A){J(fc);return this.Concat(fc).Distinct(R)}
function Join(fc,X,Y,PFn,gc){J(fc);L(X);L(Y);L(PFn);gc=f(gc,A);L(gc);const bc=this.y();return new Collection(function*(){const cc=fc[Symbol.iterator]();for(let ecValue of bc){const ecKey=X(ecValue);for(let fcValue of cc){const fcKey=Y(fcValue);if(gc(ecKey,fcKey)){yield PFn(ecValue,fcValue)}}}})}
function Except(fc){J(fc);if(!p(fc)){fc=new Collection(fc)}
const bc=this.y();return new Collection(function*(){for(let val of bc){if(!fc.Contains(val)){yield val}}})}
function Zip(fc,PFn){J(fc);L(PFn);const bc=this.y();return new Collection(function*(){const cc=fc[Symbol.iterator]();for(let ecVal of bc){const fcNext=cc.next();if(fcNext.done){break}
yield PFn(ecVal,fcNext.value)}})}
function Intersect(fc,R=A){J(fc);L(R);const bc=this.ToArray();return new Collection(function*(){const cc=[...fc];for(let val of bc){if(cc.Any(ic=>R(val,ic))){yield val}}})}
function IndexOf(icent,R=A){L(R);const iter=this.y();let i=0;for(let val of iter){if(R(val,icent)){return i}
i++}
return -1}
function LastIndexOf(icent,R=A){L(R);const iter=this.y();let i=0;let lastIndex=-1;for(let val of iter){if(R(val,icent)){lastIndex=i}
i++}
return lastIndex}
function Contains(ic,R=A){return !!~this.IndexOf(ic,R)}
function Where(Z=(ic,index)=>!0){L(Z);const iter=this.y();const result=new Collection(function*(){let index=0;for(let val of iter){if(Z(val,index)){yield val}
index++}});return result}
function ConditionalWhere(hc,Z){if(hc){return this.Where(Z)} else{return this}}
function Count(Z=ic=>!0){let count=0;
let filtered=this.Where(Z);
while(!filtered.next().done){count++;}
return count;}
function Any(Z){if(o(this)){return !1}
if(!Z){return !0}
return !this.Where(Z).next().done;}
function All(Z=ic=>!0){L(Z);return !this.Any(x=>!Z(x))}
function b(collection,originalFn,ZOrDefault=x=>!0,fallback=Object){let Z;if(j(ZOrDefault)||!n(ZOrDefault)){Z=x=>!0;fallback=ZOrDefault} else{Z=ZOrDefault}
L(Z);const defaultVal=z(fallback);if(o(collection)){return defaultVal}
let result=originalFn.call(collection,Z);if(!result){return defaultVal}
return result}
function ElementAt(index){K(this,index);const result=this.Skip(index).Take(1).ToArray()[0];this.c();return result}
function Take(count=0){G(count);if(count<=0){return Collection.Empty}
const iter=this.y();return new Collection(function*(){let i=0;for(let val of iter){yield val;if(++i===count){break}}})}
function Skip(count=0){G(count);if(count<=0){return this}
const result=this.SkipWhile((ic,index)=>index<count);this.c();return result}
function TakeWhile(Z=(ic,index)=>!0){L(Z);const iter=this.y();const result=new Collection(function*(){let index=0;let endTake=!1;for(let val of iter){if(!endTake&&Z(val,index++)){yield val;continue}
endTake=!0}});this.c();return result}
function TakeUntil(Z=(ic,index)=>!1){return this.TakeWhile((ic,index)=>!Z(ic,index))}
function SkipWhile(Z=(ic,index)=>!0){L(Z);const iter=this.y();return new Collection(function*(){let index=0;let endSkip=!1;for(let val of iter){if(!endSkip&&Z(val,index++)){continue}
endSkip=!0;yield val}})}
function SkipUntil(Z=(ic,index)=>!1){return this.SkipWhile((ic,index)=>!Z(ic,index))}
function First(Z=x=>!0){L(Z);I(this);const result=this.SkipWhile(ic=>!Z(ic)).Take(1).ToArray()[0];this.c();return result}
function FirstOrDefault(ZOrConstructor=x=>!0,constructor=Object){return b(this,First,ZOrConstructor,constructor)}
function Last(Z=x=>!0){L(Z);I(this);return this.Reverse().First(Z)}
function LastOrDefault(ZOrConstructor=x=>!0,constructor=Object){return b(this,Last,ZOrConstructor,constructor)}
function Single(Z=x=>!0){L(Z);I(this);let index=0;let result;for(let val of this.y()){if(Z(val)){result=val;break}
index++}
if(this.First(ic=>Z(ic)&&!A(ic,result))){throw new Error('Sequence contains more than one icent')}
return result}
function SingleOrDefault(ZOrConstructor=x=>!0,constructor=Object){return b(this,Single,ZOrConstructor,constructor)}
function DefaultIfEmpty(W){if(!o(this)){return this}
return [z(W)]}
let HeapElement=(function(){function HeapElement(index,value){this.__index=index;
this.__value=value;
this.__isHeapElementInstance=!0;}
HeapElement.CreateHeapElement=function CreateHeapElement(index,obj){if(obj===undefined||obj.__isHeapElementInstance){return obj;}
return new HeapElement(index,obj);};
return HeapElement;})();
let MinHeap=(function(){function MinHeap(icents,comparator=DefaultComparator){N(icents);
L(comparator);
this.icents=icents;
this.comparator=(a,b)=>{let res=comparator(a.__value,b.__value);
if(res!==0){return res;}
return DefaultComparator(a.__index,b.__index);};
B(this.icents,this.comparator);}
function r(icents,comparator,i){let right    =2*(i+1);
let left     =right-1;
let bestIndex=i;
icents[bestIndex]=HeapElement.CreateHeapElement(bestIndex,icents[bestIndex]);
if(left<icents.length){icents[left]=HeapElement.CreateHeapElement(left,icents[left]);
if(comparator(icents[left],icents[bestIndex])<0){bestIndex=left;}}
if(right<icents.length){icents[right]=HeapElement.CreateHeapElement(right,icents[right]);
if(comparator(icents[right],icents[bestIndex])<0){bestIndex=right;}}
if(bestIndex!==i){let tmp=icents[i];
icents[i]=icents[bestIndex];
icents[bestIndex]=tmp;
r(icents,comparator,bestIndex);}}
function B(icents,comparator){if(icents.length===0){return;}
for(let i=Math.floor(icents.length / 2);i>=0;i--){r(icents,comparator,i);}}
MinHeap.prototype.hasTopElement=function(){return this.icents.length>0;};
MinHeap.prototype.getTopElement=function(){if(this.icents.length===1){return this.icents.pop().__value;}
let topElement=this.icents[0];
let tmp=this.icents.pop();
this.icents[0]=tmp;
r(this.icents,this.comparator,0);
return topElement.__value;};
MinHeap.prototype[Symbol.iterator]=function(){let heap=this;
return{next:function(){if(heap.hasTopElement()){return{done:!1,
value:heap.getTopElement()};}
return{done:!0};}}};
return MinHeap;})();
let MaxHeap=(function(){function MaxHeap(icents,comparator=DefaultComparator){N(icents);
L(comparator);MinHeap.apply(this,[icents,function(a,b){return -1*comparator(a,b);}]);}
MaxHeap.prototype=Object.create(MinHeap.prototype);
MaxHeap.prototype.constructor=MaxHeap;
return MaxHeap;})();function Aggregate(seedOrAccumulator,accumulator,Q){const values=this.ToArray();if(typeof seedOrAccumulator==='function'&&!accumulator&&!Q){return C(values.slice(1,values.length),values.slice(0,1)[0],seedOrAccumulator,ic=>ic)} else if(typeof seedOrAccumulator!=='function'&&typeof accumulator==='function'&&!Q){return C(values,seedOrAccumulator,accumulator,ic=>ic)} else{return C(values,seedOrAccumulator,accumulator,Q)}}
function Select(mapFn=x=>x){const iter=this.y();let index=0;return new Collection(function*(){for(let val of iter){yield mapFn(val,index);index ++}})}
function Flatten(){return this.SelectMany(x=>x)}
function SelectMany(mapFn,P=(x,y)=>y){L(mapFn);L(P);const iter=this.y();return new Collection(function*(){let index=0;for(let current of iter){let mappedEntry=mapFn(current,index);let newIter=mappedEntry;if(!l(mappedEntry)){newIter=[mappedEntry]} else{newIter=mappedEntry}
for(let val of newIter[Symbol.iterator]()){yield P(current,val)}
index++}})}
function Distinct(R=A){L(R);return e(this,R)}
function ToArray(){return [...this.y()]}
function ToDictionary(S,UOrKeyComparer,T){L(S);if(!UOrKeyComparer&&!T){return this.ToDictionary(S,ic=>ic,A)} else if(!T&&w(UOrKeyComparer)===1){return this.ToDictionary(S,UOrKeyComparer,A)} else if(!T&&w(UOrKeyComparer)===2){return this.ToDictionary(S,ic=>ic,UOrKeyComparer)}L(T);L(UOrKeyComparer);let usedKeys=[];let result=new Map();const input=this.ToArray();const U=UOrKeyComparer;for(let value of input){let key=S(value);let ic=U(value);O(key!=null,'Key is not allowed to be null!');O(!usedKeys.Any(x=>T(x,key)),`Key '${key}' is already in use!`);usedKeys.push(key);result.set(key,ic)}
return result}
function ToJSON(){return a(this.ToArray())}
function Reverse(){const arr=this.ToArray();return new Collection(function*(){for(let i=arr.length-1;i>=0;i--){yield arr[i]}})}
function ForEach(fn){L(fn);for(let val of this.y()){fn(val)}}
function Add(value){this.Insert(value,this.Count())}
function Insert(value,index){O(index>=0&&index<=this.Count(),'Index is out of bounds!');const oldIter=this.ToArray();this.iterable=function*(){yield* oldIter.slice(0,index);yield value;yield* oldIter.slice(index,oldIter.length)}}
function Remove(value){let values=this.ToArray();const result=d(values,value);if(!result){return !1}
this.iterable=function*(){yield* values}
return !0}
let OrderedLinqCollection=(function(){function OrderedLinqCollection(iterable,comparator,heapConstructor){J(iterable);
L(comparator);
L(heapConstructor);
Collection.apply(this,[iterable]);
this.__comparator     =comparator;
this.__heapConstructor=heapConstructor;}
OrderedLinqCollection.prototype.ThenBy=function(additionalComparator){if(h(additionalComparator)){additionalComparator=GetComparatorFromKeySelector(additionalComparator);}
L(additionalComparator);
let currentComparator=this.__comparator;
this.__comparator=(a,b)=>{let res=currentComparator(a,b);
if(res!==0){return res;}
return additionalComparator(a,b);};
return this;};
OrderedLinqCollection.prototype.y=function(){const _self=this;return function*(){yield* Reflect.construct(_self.__heapConstructor,[[..._self.iterable],_self.__comparator])}()}
return OrderedLinqCollection;})();
function GetComparatorFromKeySelector(selector){F(selector);
if(selector===''){return Collection.prototype.DefaultComparator;}if(!(selector.startsWith('[')||selector.startsWith('.'))){selector=`.${selector}`;}
let result;eval(`result=function(a,b){return Collection.prototype.DefaultComparator(a${selector},b${selector})}`);
return result;}
function Order(){return this.OrderBy(DefaultComparator);}
function OrderDescending(){return this.OrderByDescending(DefaultComparator);}
function OrderBy(comparator){if(h(comparator)){comparator=GetComparatorFromKeySelector(comparator);}
L(comparator);
return new OrderedLinqCollection(this,comparator,MinHeap);};
function OrderByDescending(comparator){if(h(comparator)){comparator=GetComparatorFromKeySelector(comparator);}
L(comparator);
return new OrderedLinqCollection(this,comparator,MaxHeap);};
function Shuffle(){return this.OrderBy(()=>Math.floor(Math.random()*3)-1 )}
function GroupBy(S,...args){const arr=this.ToArray();function k(arg){let result=w(arg)===2;try{result=result&&arg(1,1)&&!arg(1,2)} catch(err){result=!1}
return result}
function x(groups,key,T){for(let groupKey of groups.keys()){if(T(groupKey,key)){return groupKey}}
return key}
function u(S){return v(S,ic=>ic,undefined,A)}
function s(S,fc){let T,U;if(k(fc)){T=fc;U=ic=>ic} else{T=A;U=fc}
return t(S,U,T)}
function t(S,fc,third){let T,U,P;if(k(third)){T=third} else{P=third}
if(w(fc)===2){P=fc} else{U=fc}
if(!T){T=A}
if(!U){U=ic=>ic}
return v(S,U,P,T)}
function v(S,U,P,T){L(S);L(U);O(g(P)||n(P),'P must be undefined or function!');L(T);let groups=new Map();let result;for(let val of arr){const key=x(groups,S(val),T);const ic=U(val);if(groups.has(key)){groups.get(key).push(ic)} else{groups.set(key,[ic])}}
if(P){result=groups.ToArray().Select(g=>P(...g))} else{result=groups}
return result}
let fn;switch(args.length){case 0:;fn=u;break;case 1:;fn=s;break;case 2:;fn=t;break;case 3:;fn=v;break;default:;throw new Error('GroupBy jceter count can not be greater than 4!')}
return fn(S,...args)}
function SequenceEqual(fc,R=A){if(!l(fc)){return !1}
const ec=this.ToArray();fc=fc.ToArray();if(ec.length!==fc.length){return !1}
for(let i=0;i<ec.length;i++){let ecVal=ec[i];let fcVal=fc[i];if(!R(ecVal,fcVal)){return !1}}
return !0}D({DefaultComparator,Min,Max,Average,Sum,Concat,Union,Join,Except,Zip,Intersect,Where,ConditionalWhere,Count,Contains,IndexOf,LastIndexOf,Any,All,ElementAt,Take,TakeWhile,TakeUntil,Skip,SkipWhile,SkipUntil,Contains,First,FirstOrDefault,Last,LastOrDefault,Single,SingleOrDefault,DefaultIfEmpty,DefaultComparator,MinHeap,MaxHeap,Aggregate,Distinct,Select,SelectMany,Flatten,Reverse,ToArray,ToDictionary,ToJSON,ForEach,Add,Insert,Remove,GetComparatorFromKeySelector,OrderedLinqCollection,Order,OrderBy,OrderDescending,OrderByDescending,Shuffle,GroupBy,SequenceEqual });E(Collection.prototype,linqjsExports);OrderedLinqCollection.prototype=E(E({},Collection.prototype),OrderedLinqCollection.prototype);
OrderedLinqCollection.prototype.constructor=OrderedLinqCollection;
const protosToApplyWrappers=[window.Array.prototype,window.Set.prototype,window.Map.prototype];Object.keys(Collection.prototype).forEach(k=>{for(let proto of protosToApplyWrappers){proto[k]=function(...args){return new Collection(this)[k](...args)}}});return Collection}()))}());