/*!
 * linqjs v0.0.0
 * (c) Sven Schmidt 
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */
(function(){'use strict';const window=this||(0,eval)('this');const DEBUG=!0;(function(Collection){try{if(typeof define==='function'&&define.amd){define(['require','exports'],function(){return Collection })}else if(exports&&module&&module.exports){exports=module.exports=Collection}} catch(err){window.Collection=Collection}}(function(){let linqjsExports={}
let Collection=(function(){function Collection(S){O(l(S)||m(S),'Parameter must be iterable or generator!');this.iterable=S}
Collection.prototype=(function(){function next(){if(!this.started){this.started=!0;this.iterator=this.x()}
return this.iterator.next()}
function c(){this.started=!1}
function x(){const iter=this.iterable;if(m(iter)){return iter()}else{return function*(){yield* iter}()}}return{next,c,x }}());Collection.prototype[Symbol.iterator]=function*(){let sd;while(!0){sd=this.next();if(sd.done){this.c();break}
yield sd.value}}
return Collection}());function From(iterable){return new Collection(iterable)}
function Range(start,qc){H(qc,0,1/0);return new Collection(function*(){let i=start;while(i!=qc+start){yield i++}})}
function Repeat(val,qc){H(qc,0,1/0);return new Collection(function*(){for(let i=0;i<qc;i++){yield val}})}Object.defineProperty(Collection,'Empty',{get:function(){return Collection.from([])}});const od={From,from:From,Range,Repeat }
E(Collection,od);function A(uc,oc){return a(uc)===a(oc)}
function defaultComparator(a,b){if(a<b){return -1}
if(b<a){return 1}
return 0}class AssertionError extends Error{constructor(expected,got){super(`Expected ${expected},got ${got}!`)}}
function O(ic,...zcs){if(!ic){if(zcs.length===1){throw new Error(msg)}else if(zcs.length===2){throw new AssertionError(...zcs)}}}
function L(rc){O(n(rc),'function',rc)}
function N(rc){O(q(rc),'array',rc)}
function I(wc){O(!o(wc),'Sequence is empty!')}
function J(ac){O(l(ac),'iterable',ac)}
function M(ac){O(p(ac),'collection',ac)}
function F(ac){O(h(ac),'string',ac)}
function G(ac){O(i(ac),'numeric value',ac)}function H(num,min,max=1/0){G(num);O(num>=min&&num<=max,`Number must be between ${min} and ${max}!`)}
function K(wc,index){M(wc);O(i(index),'number',index);O(index>=0&&index<wc.Count(),'Index is out of bounds')}
function q(ac){return ac instanceof([]).constructor}
function n(ac){return typeof ac==='function'}
function i(n){return !isNaN(parseFloat(n))}
function o(coll){if(p(coll)){return o(coll.Take(1).ToArray())}
return coll.length===0}
function l(ac){return(Symbol.iterator in Object(ac))}
function h(ac){return typeof ac==='string'}
function p(ac){return ac instanceof Collection}function m(ac){return ac instanceof(function*(){}).constructor}
function g(ac){return typeof ac===typeof undefined}
function a(ac){return JSON.stringify(ac)}
function E(tzcet,source){Object.assign(Object(tzcet),source);return tzcet}
function D(ac){E(linqjsExports,ac)}
function f(rc,value){return typeof rc==='undefined'?value:rc}
function C(coll,yc,fc,W){L(fc);L(W);I(coll);return W([yc].concat(coll).reduce(fc))}
function e(coll,X=A){J(coll);L(X);const id=[];return new Collection(function*(){const iter=coll.x();pd:for(let val of iter){sc:for(let prev of id){if(X(val,prev)){continue pd}}
id.push(val);yield val}})}
function d(arr,value){N(arr);let xcsBefore=[];let xcFound=!1;let sd;while((sd=arr.shift())&&!(xcFound=A(sd,value))){xcsBefore.push(sd)}
arr.unshift(...xcsBefore);return xcFound}
const bd=[Object,Number,Boolean,String,Symbol];function j(ac){return /native code/.test(Object(ac).toString())||!!~bd.indexOf(ac)}
function z(U=Object){if(U&&j(U)&&typeof U==='function'){let gdue=U();if(gdue instanceof Object||U===Date){return null}else{return gdue}}
return U}
function w(fn){L(fn);return fn.length}
function Min(tc=x=>x){L(tc);I(this);return Math.min.apply(null,this.Select(tc).ToArray())}
function Max(tc=x=>x){L(tc);I(this);return Math.max.apply(null,this.Select(tc).ToArray())}
function Sum(tc=x=>x){I(this);return this.Select(tc).Aggregate(0,(prev,curr)=>prev+curr)}
function Average(tc=x=>x){I(this);return this.Sum(tc)/ this.Count()}
function Concat(sc){J(sc);const pd=this;return new Collection(function*(){yield* pd.x();yield* sc})}
function Union(sc,X=A){J(sc);return this.Concat(sc).Distinct(X)}
function Join(sc,Y,Z,aa,R){J(sc);L(Y);L(Z);L(aa);R=f(R,A);L(R);const pd=this;return new Collection(function*(){for(let cd of pd.x()){const pdKey=Y(cd);for(let scValue of sc[Symbol.iterator]()){const scKey=Z(scValue);if(R(pdKey,scKey)){yield aa(cd,scValue)}}}})}
function Except(sc){J(sc);if(!p(sc)){sc=new Collection(sc)}
const pd=this;return new Collection(function*(){for(let val of pd.x()){if(!sc.Contains(val)){yield val}}})}
function Zip(sc,aa){J(sc);L(aa);const pd=this;return new Collection(function*(){const scIter=sc[Symbol.iterator]();for(let jd of pd.x()){const scNext=scIter.next();if(scNext.done){break}
yield aa(jd,scNext.value)}})}
function Intersect(sc,X=A){J(sc);L(X);const pdIter=this.ToArray();return new Collection(function*(){const scIter=[...sc];for(let val of pdIter){if(scIter.Any(xc=>X(val,xc))){yield val}}})}
function IndexOf(nc,X=A){L(X);const iter=this.x();let i=0;for(let val of iter){if(X(val,nc)){return i}
i++}
return -1}
function LastIndexOf(nc,X=A){L(X);const iter=this.x();let i=0;let nd=-1;for(let val of iter){if(X(val,nc)){nd=i}
i++}
return nd}
function Contains(xc,X=A){return !!~this.IndexOf(xc,X)}
function Where(jc=(xc,index)=>!0){L(jc);const iter=this.x();const hd=new Collection(function*(){let index=0;for(let val of iter){if(jc(val,index)){yield val}
index++}});return hd}
function ConditionalWhere(ic,jc){if(ic){return this.Where(jc)}else{return this}}
function Count(jc=xc=>!0){let qc=0;let filtered=this.Where(jc);while(!filtered.next().done){qc++}
return qc}
function Any(jc){if(o(this)){return !1}
if(!jc){return !0}
return !this.Where(jc).next().done}
function All(jc=xc=>!0){L(jc);return !this.Any(x=>!jc(x))}
function b(wc,hc,T=x=>!0,mc=Object){let jc;if(j(T)||!n(T)){jc=x=>!0;mc=T}else{jc=T}
L(jc);const gd=z(mc);if(o(wc)){return gd}
let hd=hc.call(wc,jc);if(!hd){return gd}
return hd}
function ElementAt(index){K(this,index);const hd=this.Skip(index).Take(1).ToArray()[0];this.c();return hd}
function Take(qc=0){G(qc);if(qc<=0){return Collection.Empty}
const iter=this.x();return new Collection(function*(){let i=0;for(let val of iter){yield val;if(++i===qc){break}}})}
function Skip(qc=0){G(qc);if(qc<=0){return this}
return this.SkipWhile((xc,index)=>index<qc)}
function TakeWhile(jc=(xc,index)=>!0){L(jc);const _wc=this;const hd=new Collection(function*(){let index=0;let endTake=!1;for(let val of _wc.x()){if(!endTake&&jc(val,index++)){yield val;continue}
endTake=!0}});this.c();return hd}
function TakeUntil(jc=(xc,index)=>!1){return this.TakeWhile((xc,index)=>!jc(xc,index))}
function SkipWhile(jc=(xc,index)=>!0){L(jc);const _wc=this;return new Collection(function*(){let index=0;let wd=!1;for(let val of _wc.x()){if(!wd&&jc(val,index++)){continue}
wd=!0;yield val}})}
function SkipUntil(jc=(xc,index)=>!1){return this.SkipWhile((xc,index)=>!jc(xc,index))}
function First(jc=x=>!0){L(jc);I(this);const hd=this.SkipWhile(xc=>!jc(xc)).Take(1).ToArray()[0];this.c();return hd}
function FirstOrDefault(Q=x=>!0,constructor=Object){return b(this,First,Q,constructor)}
function Last(jc=x=>!0){L(jc);I(this);return this.Reverse().First(jc)}
function LastOrDefault(Q=x=>!0,constructor=Object){return b(this,Last,Q,constructor)}
function Single(jc=x=>!0){L(jc);I(this);let index=0;let hd;for(let val of this.x()){if(jc(val)){hd=val;break}
index++}
if(this.First(xc=>jc(xc)&&!A(xc,hd))){throw new Error('Sequence contains more than one nc')}
return hd}
function SingleOrDefault(Q=x=>!0,constructor=Object){return b(this,Single,Q,constructor)}
function DefaultIfEmpty(U){if(!o(this)){return this}
return [z(U)]}
let xd=(function(){function xd(index,value){this.__index=index;this.__value=value;this.__isxdInstance=!0}
xd.Createxd=function(index,ac){if(ac===undefined||ac.__isxdInstance){return ac}
return new xd(index,ac)};return xd})();let MinHeap=(function(){function MinHeap(kc,gc=defaultComparator){N(kc);L(gc);this.kc=kc;this.gc=(a,b)=>{let res=gc(a.__value,b.__value);if(res!==0){return res}
return defaultComparator(a.__index,b.__index)};B(this.kc,this.gc)}
function r(kc,gc,i){let right=2*(i+1);let left=right-1;let bestIndex=i;kc[bestIndex]=xd.Createxd(bestIndex,kc[bestIndex]);if(left<kc.length){kc[left]=xd.Createxd(left,kc[left]);if(gc(kc[left],kc[bestIndex])<0){bestIndex=left}}
if(right<kc.length){kc[right]=xd.Createxd(right,kc[right]);if(gc(kc[right],kc[bestIndex])<0){bestIndex=right}}
if(bestIndex!==i){let tmp=kc[i];kc[i]=kc[bestIndex];kc[bestIndex]=tmp;r(kc,gc,bestIndex)}}
function B(kc,gc){if(kc.length===0){return}
for(let i=Math.floor(kc.length / 2);i>=0;i--){r(kc,gc,i)}}
MinHeap.prototype.yd=function(){return this.kc.length>0};MinHeap.prototype.getTopElement=function(){if(this.kc.length===1){return this.kc.pop().__value}
let topElement=this.kc[0];let tmp=this.kc.pop();this.kc[0]=tmp;r(this.kc,this.gc,0);return topElement.__value};MinHeap.prototype[Symbol.iterator]=function(){let heap=this;return{next:function(){if(heap.yd()){return{done:!1,
value:heap.getTopElement()}}
return{done:!0}}}};return MinHeap})();function Aggregate(V,fc,W){const values=this.ToArray();if(typeof V==='function'&&!fc&&!W){return C(values.slice(1,values.length),values.slice(0,1)[0],V,xc=>xc)}else if(typeof V!=='function'&&typeof fc==='function'&&!W){return C(values,V,fc,xc=>xc)}else{return C(values,V,fc,W)}}
function Select(tc=x=>x){const iter=this.x();let index=0;return new Collection(function*(){for(let val of iter){yield tc(val,index);index ++}})}
function Flatten(){return this.SelectMany(x=>x)}
function SelectMany(tc,cc=(x,y)=>y){L(tc);L(cc);const iter=this.x();return new Collection(function*(){let index=0;for(let sd of iter){let rd=tc(sd,index);let newIter=rd;if(!l(rd)){newIter=[rd]}else{newIter=rd}
for(let val of newIter[Symbol.iterator]()){yield cc(sd,val)}
index++}})}
function Distinct(X=A){L(X);return e(this,X)}
function ToArray(){return [...this.x()]}
function ToDictionary(ec,P,dc){L(ec);if(!P&&!dc){return this.ToDictionary(ec,xc=>xc,A)}else if(!dc&&w(P)===1){return this.ToDictionary(ec,P,A)}else if(!dc&&w(P)===2){return this.ToDictionary(ec,xc=>xc,P)}L(dc);L(P);let usedKeys=[];let hd=new Map();const input=this.ToArray();const bc=P;for(let value of input){let key=ec(value);let xc=bc(value);O(key!=null,'Key is not allowed to be null!');O(!usedKeys.Any(x=>dc(x,key)),`Key '${key}' is already in use!`);usedKeys.push(key);hd.set(key,xc)}
return hd}
function ToJSON(){return a(this.ToArray())}
function Reverse(){const arr=this.ToArray();return new Collection(function*(){for(let i=arr.length-1;i>=0;i--){yield arr[i]}})}
function ForEach(fn){L(fn);for(let val of this.x()){fn(val)}}
function Add(value){this.Insert(value,this.Count())}
function Insert(value,index){O(index>=0&&index<=this.Count(),'Index is out of bounds!');const oldIter=this.ToArray();this.iterable=function*(){yield* oldIter.slice(0,index);yield value;yield* oldIter.slice(index,oldIter.length)}}
function Remove(value){let values=this.ToArray();const hd=d(values,value);if(!hd){return !1}
this.iterable=function*(){yield* values}
return !0}
let OrderedCollection=(function(){function OrderedCollection(S,gc){L(gc);Collection.apply(this,[S]);this.__gc=gc}
OrderedCollection.prototype.ThenBy=function(ec,gc=defaultComparator){const sdComparator=this.__gc;const qd=GetComparatorFromKeySelector(ec,gc);const newComparator=(a,b)=>{const res=sdComparator(a,b);if(res!==0){return res}
return qd(a,b)}
const wc=this;return new OrderedCollection(this.x(),newComparator)};OrderedCollection.prototype.ThenByDescending=function(ec,gc=defaultComparator){return this.ThenBy(ec,(a,b)=>gc(b,a))}
OrderedCollection.prototype.x=function(){const _wc=this;return function*(){yield* Reflect.construct(MinHeap,[[..._wc.iterable],_wc.__gc])}()}
return OrderedCollection})();function GetComparatorFromKeySelector(lc,gc=defaultComparator){if(n(lc)){return new Function('gc','ecFn','a','b',`return gc(ecFn(a),ecFn(b))`).bind(null,gc,lc)}else if(h(lc)){if(!(lc.startsWith('[')||lc.startsWith('.'))){lc=`.${lc}`}return new Function('gc','a','b',`return gc(a${lc},b${lc})`).bind(null,gc)}}
function Order(gc=defaultComparator){return this.OrderBy(x=>x,gc)}
function OrderDescending(gc=defaultComparator){return this.OrderByDescending(x=>x,gc)}
function OrderBy(ec,gc=defaultComparator){L(gc);return new OrderedCollection(this,GetComparatorFromKeySelector(ec,gc),MinHeap)}
function OrderByDescending(ec,gc=defaultComparator){return new OrderedCollection(this,GetComparatorFromKeySelector(ec,(a,b)=>gc(b,a)))}
function Shuffle(){return this.OrderBy(()=>Math.floor(Math.random()*3)-1 )}
function y(pc,key,dc){for(let vd of pc.keys()){if(dc(vd,key)){return vd}}
return key}
function GroupBy(ec,...zcs){const arr=this.ToArray();function k(zc){let hd=w(zc)===2;try{hd=hd&&zc(1,1)&&!zc(1,2)} catch(err){hd=!1}
return hd}
function u(ec){return v(ec,xc=>xc,undefined,A)}
function s(ec,sc){let dc,bc;if(k(sc)){dc=sc;bc=xc=>xc}else{dc=A;bc=sc}
return t(ec,bc,dc)}
function t(ec,sc,vc){let dc,bc,cc;if(k(vc)){dc=vc}else{cc=vc}
if(w(sc)===2){cc=sc}else{bc=sc}
if(!dc){dc=A}
if(!bc){bc=xc=>xc}
return v(ec,bc,cc,dc)}
function v(ec,bc,cc,dc){L(ec);L(bc);O(g(cc)||n(cc),'cc must be undefined or function!');L(dc);let pc=new Map();let hd;for(let val of arr){const key=y(pc,ec(val),dc);const xc=bc(val);if(pc.has(key)){pc.get(key).push(xc)}else{pc.set(key,[xc])}}
if(cc){hd=pc.ToArray().Select(g=>cc(...g))}else{hd=pc}
return hd}
let fn;switch(zcs.length){case 0:;fn=u;break;case 1:;fn=s;break;case 2:;fn=t;break;case 3:;fn=v;break;default:;throw new Error('GroupBy rceter qc can not be greater than 4!')}
return fn(ec,...zcs)}
function GroupJoin(sc,Y,Z,cc,X=A){J(sc);L(Y);L(Z);L(cc);let pc=new Map();const pd=this;for(let jd of pd.x()){const pdKey=Y(jd);pc.set(jd,new Collection(function*(){for(let scVal of sc[Symbol.iterator]()){if(X(pdKey,Z(scVal))){yield scVal}}}))}
return new Collection(function*(){for(let [key,values] of pc){yield cc(key,values.ToArray())}})}
function SequenceEqual(oc,X=A){if(!l(oc)){return !1}
const uc=this.ToArray();oc=oc.ToArray();if(uc.length!==oc.length){return !1}
for(let i=0;i<uc.length;i++){let ucVal=uc[i];let ocVal=oc[i];if(!X(ucVal,ocVal)){return !1}}
return !0}D({defaultComparator,Min,Max,Average,Sum,Concat,Union,Join,Except,Zip,Intersect,Where,ConditionalWhere,Count,Contains,IndexOf,LastIndexOf,Any,All,ElementAt,Take,TakeWhile,TakeUntil,Skip,SkipWhile,SkipUntil,Contains,First,FirstOrDefault,Last,LastOrDefault,Single,SingleOrDefault,DefaultIfEmpty,MinHeap,Aggregate,Distinct,Select,SelectMany,Flatten,Reverse,ToArray,ToDictionary,ToJSON,ForEach,Add,Insert,Remove,GetComparatorFromKeySelector,OrderedCollection,Order,OrderBy,OrderDescending,OrderByDescending,Shuffle,GroupBy,GroupJoin,SequenceEqual });E(Collection.prototype,linqjsExports);OrderedCollection.prototype=E(E({},Collection.prototype),OrderedCollection.prototype);OrderedCollection.prototype.constructor=OrderedCollection;const protosToApplyWrappers=[window.Array.prototype,window.Set.prototype,window.Map.prototype];Object.keys(Collection.prototype).forEach(k=>{for(let proto of protosToApplyWrappers){proto[k]=function(...zcs){return new Collection(this)[k](...zcs)}}});return Collection}()))}());