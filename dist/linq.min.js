/*!
 * linqjs v0.0.0
 * (c) Sven Schmidt 
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */
(function(){'use strict';const window=this||(0,eval)('this');const DEBUG=!0;(function(Collection){try{if(typeof define==='function'&&define.amd){define(['require','exports'],function(){return Collection })}else if(exports&&module&&module.exports){exports=module.exports=Collection}} catch(err){window.Collection=Collection}}(function(){let linqjsExports={}
let Collection=(function(){function Collection(T){P(m(T)||n(T),'Parameter must be iterable or generator!');this.iterable=T}
Collection.prototype=(function(){function next(){if(!this.started){this.started=!0;this.iterator=this.y()}
return this.iterator.next()}
function c(){this.started=!1}
function y(){const iter=this.iterable;if(n(iter)){return iter()}else{return function*(){yield* iter}()}}return{next,c,y }}());Collection.prototype[Symbol.iterator]=function*(){let xd;while(!0){xd=this.next();if(xd.done){this.c();break}
yield xd.value}}
return Collection}());function From(iterable){return new Collection(iterable)}
function Range(start,uc){I(uc,0,1/0);return new Collection(function*(){let i=start;while(i!=uc+start){yield i++}})}
function Repeat(val,uc){I(uc,0,1/0);return new Collection(function*(){for(let i=0;i<uc;i++){yield val}})}Object.defineProperty(Collection,'Empty',{get:function(){return Collection.from([])}});const td={From,from:From,Range,Repeat }
F(Collection,td);function B(zc,rc){return a(zc)===a(rc)}
function defaultComparator(a,b){if(a<b){return -1}
if(b<a){return 1}
return 0}class AssertionError extends Error{constructor(expected,got){super(`Expected ${expected},got ${got}!`)}}
function P(lc,...fds){if(!lc){if(fds.length===1){throw new Error(msg)}else if(fds.length===2){throw new AssertionError(...fds)}}}
function M(vc){P(o(vc),'function',vc)}
function O(vc){P(r(vc),'array',vc)}
function J(dd){P(!p(dd),'Sequence is empty!')}
function K(ed){P(m(ed),'iterable',ed)}
function N(ed){P(q(ed),'collection',ed)}
function G(ed){P(i(ed),'string',ed)}
function H(ed){P(j(ed),'numeric value',ed)}function I(num,min,max=1/0){H(num);P(num>=min&&num<=max,`Number must be between ${min} and ${max}!`)}
function L(dd,index){N(dd);P(j(index),'number',index);P(index>=0&&index<dd.Count(),'Index is out of bounds')}
function r(ed){return ed instanceof([]).constructor}
function o(ed){return typeof ed==='function'}
function j(n){return !isNaN(parseFloat(n))}
function p(coll){if(q(coll)){return p(coll.Take(1).ToArray())}
return coll.length===0}
function m(ed){return(Symbol.iterator in Object(ed))}
function i(ed){return typeof ed==='string'}
function q(ed){return ed instanceof Collection}function n(ed){return ed instanceof(function*(){}).constructor}
function h(ed){return typeof ed===typeof undefined}
function g(cd,yc,ic){let md=[];let il=0;let ir=0;while(il<cd.length&&ir<yc.length){if(ic(cd[il],yc[ir])<0){md.push(cd[il++])}else{md.push(yc[ir++])}}
return md.concat(cd.slice(il)).concat(yc.slice(ir))}
function gSort(wc,ic=defaultComparator){if(wc.length<2){return wc}
const middle=Math.floor(wc.length / 2);const cd=wc.slice(0,middle);const yc=wc.slice(middle);const vcs=g(;gSort(cd,ic),
gSort(yc,ic),
ic);vcs.unshift(0,wc.length);wc.splice.apply(wc,vcs);return wc}
function a(ed){return JSON.stringify(ed)}
function F(tfdet,source){Object.assign(Object(tfdet),source);return tfdet}
function E(ed){F(linqjsExports,ed)}
function f(vc,value){return typeof vc==='undefined'?value:vc}
function D(coll,ac,fc,X){M(fc);M(X);J(coll);return X([ac].concat(coll).reduce(fc))}
function e(coll,Y=B){K(coll);M(Y);const nd=[];return new Collection(function*(){const iter=coll.y();ud:for(let val of iter){xc:for(let prev of nd){if(Y(val,prev)){continue ud}}
nd.push(val);yield val}})}
function d(arr,value){O(arr);let bdsBefore=[];let bdFound=!1;let xd;while((xd=arr.shift())&&!(bdFound=B(xd,value))){bdsBefore.push(xd)}
arr.unshift(...bdsBefore);return bdFound}
const gd=[Object,Number,Boolean,String,Symbol];function k(ed){return /native code/.test(Object(ed).toString())||!!~gd.indexOf(ed)}
function A(V=Object){if(V&&k(V)&&typeof V==='function'){let ldue=V();if(ldue instanceof Object||V===Date){return null}else{return ldue}}
return V}
function x(fn){M(fn);return fn.length}
function Min(sc=x=>x){M(sc);J(this);return Math.min.apply(null,this.Select(sc).ToArray())}
function Max(sc=x=>x){M(sc);J(this);return Math.max.apply(null,this.Select(sc).ToArray())}
function Sum(sc=x=>x){J(this);return this.Select(sc).Aggregate(0,(prev,curr)=>prev+curr)}
function Average(sc=x=>x){J(this);return this.Sum(sc)/ this.Count()}
function Concat(xc){K(xc);const ud=this;return new Collection(function*(){yield* ud.y();yield* xc})}
function Union(xc,Y=B){K(xc);return this.Concat(xc).Distinct(Y)}
function Join(xc,Z,aa,bc,S){K(xc);M(Z);M(aa);M(bc);S=f(S,B);M(S);const ud=this;return new Collection(function*(){for(let hd of ud.y()){const udKey=Z(hd);for(let xcValue of xc[Symbol.iterator]()){const xcKey=aa(xcValue);if(S(udKey,xcKey)){yield bc(hd,xcValue)}}}})}
function Except(xc){K(xc);if(!q(xc)){xc=new Collection(xc)}
const ud=this;return new Collection(function*(){for(let val of ud.y()){if(!xc.Contains(val)){yield val}}})}
function Zip(xc,bc){K(xc);M(bc);const ud=this;return new Collection(function*(){const xcIter=xc[Symbol.iterator]();for(let od of ud.y()){const xcNext=xcIter.next();if(xcNext.done){break}
yield bc(od,xcNext.value)}})}
function Intersect(xc,Y=B){K(xc);M(Y);const udIter=this.ToArray();return new Collection(function*(){const xcIter=[...xc];for(let val of udIter){if(xcIter.Any(bd=>Y(val,bd))){yield val}}})}
function IndexOf(pc,Y=B){M(Y);const iter=this.y();let i=0;for(let val of iter){if(Y(val,pc)){return i}
i++}
return -1}
function LastIndexOf(pc,Y=B){M(Y);const iter=this.y();let i=0;let sd=-1;for(let val of iter){if(Y(val,pc)){sd=i}
i++}
return sd}
function Contains(bd,Y=B){return !!~this.IndexOf(bd,Y)}
function Where(kc=(bd,index)=>!0){M(kc);const iter=this.y();const md=new Collection(function*(){let index=0;for(let val of iter){if(kc(val,index)){yield val}
index++}});return md}
function ConditionalWhere(lc,kc){if(lc){return this.Where(kc)}else{return this}}
function Count(kc=bd=>!0){let uc=0;let filtered=this.Where(kc);while(!filtered.next().done){uc++}
return uc}
function Any(kc){if(p(this)){return !1}
if(!kc){return !0}
return !this.Where(kc).next().done}
function All(kc=bd=>!0){M(kc);return !this.Any(x=>!kc(x))}
function b(dd,jc,U=x=>!0,mc=Object){let kc;if(k(U)||!o(U)){kc=x=>!0;mc=U}else{kc=U}
M(kc);const ld=A(mc);if(p(dd)){return ld}
let md=jc.call(dd,kc);if(!md){return ld}
return md}
function ElementAt(index){L(this,index);const md=this.Skip(index).Take(1).ToArray()[0];this.c();return md}
function Take(uc=0){H(uc);if(uc<=0){return Collection.Empty}
const iter=this.y();return new Collection(function*(){let i=0;for(let val of iter){yield val;if(++i===uc){break}}})}
function Skip(uc=0){H(uc);if(uc<=0){return this}
return this.SkipWhile((bd,index)=>index<uc)}
function TakeWhile(kc=(bd,index)=>!0){M(kc);const _dd=this;const md=new Collection(function*(){let index=0;let endTake=!1;for(let val of _dd.y()){if(!endTake&&kc(val,index++)){yield val;continue}
endTake=!0}});this.c();return md}
function TakeUntil(kc=(bd,index)=>!1){return this.TakeWhile((bd,index)=>!kc(bd,index))}
function SkipWhile(kc=(bd,index)=>!0){M(kc);const _dd=this;return new Collection(function*(){let index=0;let be=!1;for(let val of _dd.y()){if(!be&&kc(val,index++)){continue}
be=!0;yield val}})}
function SkipUntil(kc=(bd,index)=>!1){return this.SkipWhile((bd,index)=>!kc(bd,index))}
function First(kc=x=>!0){M(kc);J(this);const md=this.SkipWhile(bd=>!kc(bd)).Take(1).ToArray()[0];this.c();return md}
function FirstOrDefault(R=x=>!0,constructor=Object){return b(this,First,R,constructor)}
function Last(kc=x=>!0){M(kc);J(this);return this.Reverse().First(kc)}
function LastOrDefault(R=x=>!0,constructor=Object){return b(this,Last,R,constructor)}
function Single(kc=x=>!0){M(kc);J(this);let index=0;let md;for(let val of this.y()){if(kc(val)){md=val;break}
index++}
if(this.First(bd=>kc(bd)&&!B(bd,md))){throw new Error('Sequence contains more than one pc')}
return md}
function SingleOrDefault(R=x=>!0,constructor=Object){return b(this,Single,R,constructor)}
function DefaultIfEmpty(V){if(!p(this)){return this}
return [A(V)]}
let ce=(function(){function ce(index,value){this.__index=index;this.__value=value;this.__isceInstance=!0}
ce.Createce=function(index,ed){if(ed===undefined||ed.__isceInstance){return ed}
return new ce(index,ed)};return ce})();let MinHeap=(function(){function MinHeap(oc,ic=defaultComparator){O(oc);M(ic);this.oc=oc;this.ic=(a,b)=>{let res=ic(a.__value,b.__value);if(res!==0){return res}
return defaultComparator(a.__index,b.__index)};C(this.oc,this.ic)}
function s(oc,ic,i){let yc=2*(i+1);let cd=yc-1;let bestIndex=i;oc[bestIndex]=ce.Createce(bestIndex,oc[bestIndex]);if(cd<oc.length){oc[cd]=ce.Createce(cd,oc[cd]);if(ic(oc[cd],oc[bestIndex])<0){bestIndex=cd}}
if(yc<oc.length){oc[yc]=ce.Createce(yc,oc[yc]);if(ic(oc[yc],oc[bestIndex])<0){bestIndex=yc}}
if(bestIndex!==i){let tmp=oc[i];oc[i]=oc[bestIndex];oc[bestIndex]=tmp;s(oc,ic,bestIndex)}}
function C(oc,ic){if(oc.length===0){return}
for(let i=Math.floor(oc.length / 2);i>=0;i--){s(oc,ic,i)}}
MinHeap.prototype.de=function(){return this.oc.length>0};MinHeap.prototype.getTopElement=function(){if(this.oc.length===1){return this.oc.pop().__value}
let topElement=this.oc[0];let tmp=this.oc.pop();this.oc[0]=tmp;s(this.oc,this.ic,0);return topElement.__value};MinHeap.prototype[Symbol.iterator]=function(){let heap=this;return{next:function(){if(heap.de()){return{done:!1,
value:heap.getTopElement()}}
return{done:!0}}}};return MinHeap})();let MaxHeap=(function(){function MaxHeap(oc,ic=defaultComparator){O(oc);M(ic);MinHeap.apply(this,[oc,function(a,b){return -1*ic(a,b)}])}
MaxHeap.prototype=Object.create(MinHeap.prototype);MaxHeap.prototype.constructor=MaxHeap;return MaxHeap})();function Aggregate(W,fc,X){const values=this.ToArray();if(typeof W==='function'&&!fc&&!X){return D(values.slice(1,values.length),values.slice(0,1)[0],W,bd=>bd)}else if(typeof W!=='function'&&typeof fc==='function'&&!X){return D(values,W,fc,bd=>bd)}else{return D(values,W,fc,X)}}
function Select(sc=x=>x){const iter=this.y();let index=0;return new Collection(function*(){for(let val of iter){yield sc(val,index);index ++}})}
function Flatten(){return this.SelectMany(x=>x)}
function SelectMany(sc,ec=(x,y)=>y){M(sc);M(ec);const iter=this.y();return new Collection(function*(){let index=0;for(let xd of iter){let wd=sc(xd,index);let newIter=wd;if(!m(wd)){newIter=[wd]}else{newIter=wd}
for(let val of newIter[Symbol.iterator]()){yield ec(xd,val)}
index++}})}
function Distinct(Y=B){M(Y);return e(this,Y)}
function ToArray(){return [...this.y()]}
function ToDictionary(hc,Q,gc){M(hc);if(!Q&&!gc){return this.ToDictionary(hc,bd=>bd,B)}else if(!gc&&x(Q)===1){return this.ToDictionary(hc,Q,B)}else if(!gc&&x(Q)===2){return this.ToDictionary(hc,bd=>bd,Q)}M(gc);M(Q);let usedKeys=[];let md=new Map();const input=this.ToArray();const dc=Q;for(let value of input){let key=hc(value);let bd=dc(value);P(key!=null,'Key is not allowed to be null!');P(!usedKeys.Any(x=>gc(x,key)),`Key '${key}' is already in use!`);usedKeys.push(key);md.set(key,bd)}
return md}
function ToJSON(){return a(this.ToArray())}
function Reverse(){const arr=this.ToArray();return new Collection(function*(){for(let i=arr.length-1;i>=0;i--){yield arr[i]}})}
function ForEach(fn){M(fn);for(let val of this.y()){fn(val)}}
function Add(value){this.Insert(value,this.Count())}
function Insert(value,index){P(index>=0&&index<=this.Count(),'Index is out of bounds!');const oldIter=this.ToArray();this.iterable=function*(){yield* oldIter.slice(0,index);yield value;yield* oldIter.slice(index,oldIter.length)}}
function Remove(value){let values=this.ToArray();const md=d(values,value);if(!md){return !1}
this.iterable=function*(){yield* values}
return !0}
let OrderedCollection=(function(){function OrderedCollection(iterable,ic,cc){K(iterable);M(ic);M(cc);Collection.apply(this,[iterable]);this.__ic=ic;this.__cc=cc}
OrderedCollection.prototype.ThenBy=function(hc,ic=defaultComparator){const xdComparator=this.__ic;const vd=GetComparatorFromKeySelector(hc,ic);const factor=this.__cc===MaxHeap?-1:1;const newComparator=(a,b)=>{const res=factor*xdComparator(a,b);if(res!==0){return res}
return vd(a,b)}
const dd=this;return new Collection(function*(){const arr=dd.ToArray();yield* gSort(arr,newComparator)})};OrderedCollection.prototype.ThenByDescending=function(hc,ic=defaultComparator){return this.ThenBy(hc,(a,b)=>ic(b,a))}
OrderedCollection.prototype.y=function(){const _dd=this;return function*(){yield* Reflect.construct(_dd.__cc,[[..._dd.iterable],_dd.__ic])}()}
return OrderedCollection})();function GetComparatorFromKeySelector(nc,ic=defaultComparator){if(o(nc)){return new Function('ic','hcFn','a','b',`return ic(hcFn(a),hcFn(b))`).bind(null,ic,nc)}else if(i(nc)){if(nc===''){return ic}if(!(nc.startsWith('[')||nc.startsWith('.'))){nc=`.${nc}`}return new Function('ic','a','b',`return ic(a${nc},b${nc})`).bind(null,ic)}}
function Order(ic=defaultComparator){return this.OrderBy(x=>x,ic)}
function OrderDescending(ic=defaultComparator){return this.OrderByDescending(x=>x,ic)}
function OrderBy(hc,ic=defaultComparator){M(ic);return new OrderedCollection(this,GetComparatorFromKeySelector(hc,ic),MinHeap)}
function OrderByDescending(hc,ic=defaultComparator){return new OrderedCollection(this,GetComparatorFromKeySelector(hc,ic),MaxHeap)}
function Shuffle(){return this.OrderBy(()=>Math.floor(Math.random()*3)-1 )}
function z(qc,key,gc){for(let ad of qc.keys()){if(gc(ad,key)){return ad}}
return key}
function GroupBy(hc,...fds){const arr=this.ToArray();function l(fd){let md=x(fd)===2;try{md=md&&fd(1,1)&&!fd(1,2)} catch(err){md=!1}
return md}
function v(hc){return w(hc,bd=>bd,undefined,B)}
function t(hc,xc){let gc,dc;if(l(xc)){gc=xc;dc=bd=>bd}else{gc=B;dc=xc}
return u(hc,dc,gc)}
function u(hc,xc,tc){let gc,dc,ec;if(l(tc)){gc=tc}else{ec=tc}
if(x(xc)===2){ec=xc}else{dc=xc}
if(!gc){gc=B}
if(!dc){dc=bd=>bd}
return w(hc,dc,ec,gc)}
function w(hc,dc,ec,gc){M(hc);M(dc);P(h(ec)||o(ec),'ec must be undefined or function!');M(gc);let qc=new Map();let md;for(let val of arr){const key=z(qc,hc(val),gc);const bd=dc(val);if(qc.has(key)){qc.get(key).push(bd)}else{qc.set(key,[bd])}}
if(ec){md=qc.ToArray().Select(g=>ec(...g))}else{md=qc}
return md}
let fn;switch(fds.length){case 0:;fn=v;break;case 1:;fn=t;break;case 2:;fn=u;break;case 3:;fn=w;break;default:;throw new Error('GroupBy vceter uc can not be greater than 4!')}
return fn(hc,...fds)}
function GroupJoin(xc,Z,aa,ec,Y=B){K(xc);M(Z);M(aa);M(ec);let qc=new Map();const ud=this;for(let od of ud.y()){const udKey=Z(od);qc.set(od,new Collection(function*(){for(let xcVal of xc[Symbol.iterator]()){if(Y(udKey,aa(xcVal))){yield xcVal}}}))}
return new Collection(function*(){for(let [key,values] of qc){yield ec(key,values.ToArray())}})}
function SequenceEqual(rc,Y=B){if(!m(rc)){return !1}
const zc=this.ToArray();rc=rc.ToArray();if(zc.length!==rc.length){return !1}
for(let i=0;i<zc.length;i++){let zcVal=zc[i];let rcVal=rc[i];if(!Y(zcVal,rcVal)){return !1}}
return !0}E({defaultComparator,Min,Max,Average,Sum,Concat,Union,Join,Except,Zip,Intersect,Where,ConditionalWhere,Count,Contains,IndexOf,LastIndexOf,Any,All,ElementAt,Take,TakeWhile,TakeUntil,Skip,SkipWhile,SkipUntil,Contains,First,FirstOrDefault,Last,LastOrDefault,Single,SingleOrDefault,DefaultIfEmpty,MinHeap,MaxHeap,Aggregate,Distinct,Select,SelectMany,Flatten,Reverse,ToArray,ToDictionary,ToJSON,ForEach,Add,Insert,Remove,GetComparatorFromKeySelector,OrderedCollection,Order,OrderBy,OrderDescending,OrderByDescending,Shuffle,GroupBy,GroupJoin,SequenceEqual });F(Collection.prototype,linqjsExports);OrderedCollection.prototype=F(F({},Collection.prototype),OrderedCollection.prototype);OrderedCollection.prototype.constructor=OrderedCollection;const protosToApplyWrappers=[window.Array.prototype,window.Set.prototype,window.Map.prototype];Object.keys(Collection.prototype).forEach(k=>{for(let proto of protosToApplyWrappers){proto[k]=function(...fds){return new Collection(this)[k](...fds)}}});return Collection}()))}());