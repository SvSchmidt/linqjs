/*!
 * linqjs v0.0.0
 * (c) Sven Schmidt 
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */
(function(){
'use strict';
const window=this||(0,eval)('this');  const DEBUG=true;
(function(Collection){
try {
if(typeof define==='function'&&define.amd){
define(['require','exports'],function(){ return Collection })
} else if(exports&&module&&module.exports){
exports=module.exports=Collection
}
} catch(err){
window.Collection=Collection
}
}(function(){
let linqjsExports={}
let Collection;Collection=(function(){
function Collection(iterableOrGenerator){
__(isIterable(iterableOrGenerator)||isGenerator(iterableOrGenerator),'Parameter must be iterable or generator!');this.iterable=iterableOrGenerator
}
Collection.prototype=(function(){
function next(){
if(!this.started){
this.started=true;this.iterator=this.getIterator()
}
return this.iterator.next()
}
function reset(){
this.started=false
}
function getIterator(){
const iter=this.iterable;if(isGenerator(iter)){
return iter()
} else {
return function *(){
yield* iter
}()
}
}
return { next,reset,getIterator };
}());Collection.prototype[Symbol.iterator]=function *(){
let current;while(true){
current=this.next();if(current.done){
this.reset();break
}
yield current.value
}
}
return Collection
}());function from(iterable){
return new Collection(iterable)
}
function Range(start,count){
__a(count,0,Infinity);return new Collection(function *(){
let i=start;while(i!=count+start){
yield i++
}
})
}
Object.defineProperty(Collection,'Empty',{
get: function(){ return Collection.from([])}
});const collectionStaticMethods={ from,From: from,Range }
__assign(Collection,collectionStaticMethods);function defaultEqualityCompareFn(first,second){
return toJSON(first)===toJSON(second)
}
function DefaultComparator(a,b){
if(a<b){
return -1;
}
if(b<a){
return 1;
}
return 0;
};
function __(condition,msg){
if(!condition){
throw new Error(msg);
}
}
function __b(param){
__(isFunction(param),'Parameter must be function!')
}
function __c(param){
__(isArray(param),'Parameter must be array!')
}
function __d(coll){
__(!isEmpty(coll),'Sequence is empty')
}
function __e(obj){
__(isIterable(obj),'Parameter must be iterable!')
}
function __f(obj){
__(isCollection(obj),'Pa>rameter must be collection!')
}
function __g(collection){
__(!(collection.hasOwnProperty('StartedIterating')&&collection.StartedIterating()),'Iteration already started!')
}
function __h(obj){
__(isString(obj),'Parameter must be string!')
}
function __i(obj){
__(isNumeric(obj),'Parameter must be numeric!')
}
function __a(num,min,max=Infinity){
__i(num);__(num >= min&&num<=max,`Number must be between ${min} and ${max}!`)
}
function __j(coll,index){
__f(coll);__(isNumeric(index),'Index must be number!');__(index >= 0&&index<coll.Count(),'Index is out of bounds')
}
function isArray(obj){
return obj instanceof([]).constructor;
}
function isFunction(obj){
return typeof obj==='function'
}
function isNumeric(n){
return !isNaN(parseFloat(n))
}
function isEmpty(coll){
if(isCollection(coll)){
return isEmpty(coll.Take(1).ToArray())
}
return coll.length===0
}
function isIterable(obj){
return(Symbol.iterator in Object(obj))
}
function isString(obj){
return typeof obj==='string';
}
function isCollection(obj){
return obj instanceof Collection
}
function isGenerator(obj){
return obj instanceof(function *(){}).constructor;
}
function isUndefined(obj){
return typeof obj===typeof undefined
}
function toJSON(obj){
return JSON.stringify(obj)
}
function __assign(target,source){
Object.assign(Object(target),source);return target
}
function __export(obj){
__assign(linqjsExports,obj)
}
function paramOrValue(param,value){
return typeof param==='undefined'
? value
: param
}
function aggregateCollection(coll,seed,accumulator,resultTransformFn){
__b(accumulator);__b(resultTransformFn);__d(coll);return resultTransformFn([seed].concat(coll).reduce(accumulator))
}
function removeDuplicates(coll,equalityCompareFn=defaultEqualityCompareFn){
__e(coll);__b(equalityCompareFn);const previous=[];return new Collection(function *(){
const iter=coll.getIterator();outer: for(let val of iter){
inner: for(let prev of previous){
if(equalityCompareFn(val,prev)){
continue outer;
}
}
previous.push(val);yield val
}
})
}
function removeFromArray(arr,value){
__c(arr);let elemsBefore=[];let elemFound=false;let current;while((current=arr.shift())&&!(elemFound=defaultEqualityCompareFn(current,value))){
elemsBefore.push(current)
}
arr.unshift(...elemsBefore);return elemFound
}
const nativeConstructors=[Object,Number,Boolean,String,Symbol];function isNative(obj){
return /native code/.test(Object(obj).toString())||!!~nativeConstructors.indexOf(obj)
}
function getDefault(constructorOrValue=Object){
if(constructorOrValue&&isNative(constructorOrValue)&&typeof constructorOrValue==='function'){
let defaultValue=constructorOrValue();if(defaultValue instanceof Object||constructorOrValue===Date){
return null
} else {
return defaultValue
}
}
return constructorOrValue
}
function getParameterCount(fn){
__b(fn);return fn.length
}
function Min(mapFn=x => x){
__b(mapFn);__d(this);return Math.min.apply(null,this.Select(mapFn).ToArray())
}
function Max(mapFn=x => x){
__b(mapFn);__d(this);return Math.max.apply(null,this.Select(mapFn).ToArray())
}
function Sum(){
__d(this);return this.Aggregate(0,(prev,curr)=> prev+curr)
}
function Average(){
__d(this);return this.Sum()/ this.Count()
}
function Concat(second){
__e(second);const firstIter=this;if(!isCollection(second)){
second=new Collection(second)
}
return new Collection(function *(){
yield* firstIter;yield* second.getIterator()
})
}
function Union(second,equalityCompareFn=defaultEqualityCompareFn){
__e(second);return this.Concat(second).Distinct(equalityCompareFn)
}
function Join(second,firstKeySelector,secondKeySelector,resultSelectorFn,keyEqualityCompareFn){
__e(second);__b(firstKeySelector);__b(secondKeySelector);__b(resultSelectorFn);keyEqualityCompareFn=paramOrValue(keyEqualityCompareFn,defaultEqualityCompareFn);__b(keyEqualityCompareFn);const firstIter=this;const result=new Collection(function *(){
const secondIter=second.getIterator();for(let firstValue of firstIter){
const firstKey=firstKeySelector(firstValue);for(let secondValue of secondIter){
const secondKey=secondKeySelector(secondValue);if(keyEqualityCompareFn(firstKey,secondKey)){
yield resultSelectorFn(firstValue,secondValue)
}
}
}
});this.reset();return result
}
function Except(second){
__e(second);const firstIter=this;const result=new Collection(function *(){
for(let val of firstIter){
if(!second.Contains(val)){
yield val
}
}
});this.reset();second.reset&&second.reset();return result
}
function Zip(second,resultSelectorFn){
__e(second);__b(resultSelectorFn);const firstIter=this;const result=new Collection(function *(){
const secondIter=second.getIterator();for(let firstVal of firstIter){
const secondNext=secondIter.next();if(secondNext.done){
break
}
yield resultSelectorFn(firstVal,secondNext.value)
}
});this.reset();return result
}
function Contains(elem){
let result=false;for(let val of this){
if(defaultEqualityCompareFn(elem,val)){
result=true;break
}
}
this.reset();return result
}
function Where(predicate=(elem,index)=> true){
__b(predicate);const iter=this.getIterator();const result=new Collection(function *(){
let index=0;for(let val of iter){
if(predicate(val,index)){
yield val
}
index++
}
});return result
}
function ConditionalWhere(condition,predicate){
if(condition){
return this.Where(predicate)
} else {
return this
}
}
function Count(predicate=elem => true){
let count=0;
let filtered=this.Where(predicate);
while(!filtered.next().done){
count++;
}
return count;
}
function Any(predicate){
if(isEmpty(this)){
return false
}
if(!predicate){
return true
}
return !this.Where(predicate).next().done;
}
function All(predicate=elem => true){
__b(predicate);return !this.Any(x => !predicate(x))
}
function ElementAt(index){
__j(this,index);const result=this.Skip(index).Take(1).ToArray()[0];this.reset();return result
}
function Take(count=0){
__(isNumeric(count),'First parameter must be numeric!');if(count<=0){
return Collection.Empty
}
const iter=this.getIterator();return new Collection(function *(){
let i=0;for(let val of iter){
yield val;if(++i===count){
break
}
}
})
}
function Skip(count=0){
__(isNumeric(count),'First parameter must be numeric!');if(count<=0){
return this
}
const result=this.SkipWhile((elem,index)=> index<count);this.reset();return result
}
function TakeWhile(predicate=(elem,index)=> true){
__b(predicate);const iter=this.getIterator();const result=new Collection(function *(){
let index=0;let endTake=false;for(let val of iter){
if(!endTake&&predicate(val,index++)){
yield val;continue
}
endTake=true
}
});this.reset();return result
}
function TakeUntil(predicate=(elem,index)=> false){
return this.TakeWhile((elem,index)=> !predicate(elem,index))
}
function SkipWhile(predicate=(elem,index)=> true){
__b(predicate);const iter=this.getIterator();return new Collection(function *(){
let index=0;let endSkip=false;for(let val of iter){
if(!endSkip&&predicate(val,index++)){
continue
}
endSkip=true;yield val
}
})
}
function SkipUntil(predicate=(elem,index)=> false){
return this.SkipWhile((elem,index)=> !predicate(elem,index))
}
function resultOrDefault(collection,originalFn,predicateOrConstructor=x => true,constructor=Object){
let predicate;if(isNative(predicateOrConstructor)){
predicate=x => true;constructor=predicateOrConstructor
} else {
predicate=predicateOrConstructor
}
__b(predicate);__(isNative(constructor),'constructor must be native constructor,e.g. Number!');const defaultVal=getDefault(constructor);if(isEmpty(collection)){
return defaultVal
}
return originalFn.call(collection,predicate)
}
function First(predicate=x => true){
__b(predicate);__d(this);const result=this.SkipWhile(elem => !predicate(elem)).Take(1).ToArray()[0];this.reset();return result
}
function FirstOrDefault(predicateOrConstructor=x => true,constructor=Object){
return resultOrDefault(this,First,predicateOrConstructor,constructor)
}
function Last(predicate=x => true){
__b(predicate);__d(this);return this.Reverse().First(predicate)
}
function LastOrDefault(predicateOrConstructor=x => true,constructor=Object){
return resultOrDefault(this,Last,predicateOrConstructor,constructor)
}
function Single(predicate=x => true){
__b(predicate);__d(this);let index=0;let result;for(let val of this.getIterator()){
if(predicate(val)){
result=val;break
}
index++
}
if(this.First(elem => predicate(elem)&&!defaultEqualityCompareFn(elem,result))){
throw new Error('Sequence contains more than one element')
}
return result
}
function SingleOrDefault(predicateOrConstructor=x => true,constructor=Object){
return resultOrDefault(this,Single,predicateOrConstructor,constructor)
}
function DefaultIfEmpty(constructorOrValue){
if(!isEmpty(this)){
return this
}
return [getDefault(constructorOrValue)]
}
let HeapElement=(function(){
function HeapElement(index,value){
this.__index=index;
this.__value=value;
this.__isHeapElementInstance=true;
}
HeapElement.CreateHeapElement=function CreateHeapElement(index,obj){
if(obj===undefined||obj.__isHeapElementInstance){
return obj;
}
return new HeapElement(index,obj);
};
return HeapElement;
})();
let MinHeap=(function(){
function MinHeap(elements,comparator=DefaultComparator){
__c(elements);
__b(comparator);
this.elements=elements;
this.comparator=(a,b)=> {
let res=comparator(a.__value,b.__value);
if(res!==0){
return res;
}
return DefaultComparator(a.__index,b.__index);
};
createHeap(this.elements,this.comparator);
}
function heapify(elements,comparator,i){
let right    =2 *(i+1);
let left     =right-1;
let bestIndex=i;
elements[bestIndex]=HeapElement.CreateHeapElement(bestIndex,elements[bestIndex]);
if(left<elements.length){
elements[left]=HeapElement.CreateHeapElement(left,elements[left]);
if(comparator(elements[left],elements[bestIndex])<0){
bestIndex=left;
}
}
if(right<elements.length){
elements[right]=HeapElement.CreateHeapElement(right,elements[right]);
if(comparator(elements[right],elements[bestIndex])<0){
bestIndex=right;
}
}
if(bestIndex!==i){
let tmp=elements[i];
elements[i]=elements[bestIndex];
elements[bestIndex]=tmp;
heapify(elements,comparator,bestIndex);
}
}
function createHeap(elements,comparator){
if(elements.length===0){
return;
}
for(let i=Math.floor(elements.length / 2);i >= 0;i--){
heapify(elements,comparator,i);
}
}
MinHeap.prototype.hasTopElement=function(){
return this.elements.length>0;
};
MinHeap.prototype.getTopElement=function(){
if(this.elements.length===1){
return this.elements.pop().__value;
}
let topElement=this.elements[0];
let tmp=this.elements.pop();
this.elements[0]=tmp;
heapify(this.elements,this.comparator,0);
return topElement.__value;
};
MinHeap.prototype[Symbol.iterator]=function(){
let heap=this;
return {
next: function(){
if(heap.hasTopElement()){
return {
done:  false,
value: heap.getTopElement()
};
}
return {
done: true
};
}
}
};
return MinHeap;
})();
let MaxHeap=(function(){
function MaxHeap(elements,comparator=DefaultComparator){
__c(elements);
__b(comparator);
MinHeap.apply(this,[elements,function(a,b){ return -1 * comparator(a,b);}]);
}
MaxHeap.prototype=Object.create(MinHeap.prototype);
MaxHeap.prototype.constructor=MaxHeap;
return MaxHeap;
})();function Aggregate(seedOrAccumulator,accumulator,resultTransformFn){
const values=this.ToArray();if(typeof seedOrAccumulator==='function'&&!accumulator&&!resultTransformFn){
return aggregateCollection(values.slice(1,values.length),values.slice(0,1)[0],seedOrAccumulator,elem => elem)
} else if(typeof seedOrAccumulator!=='function'&&typeof accumulator==='function'&&!resultTransformFn){
return aggregateCollection(values,seedOrAccumulator,accumulator,elem => elem)
} else {
return aggregateCollection(values,seedOrAccumulator,accumulator,resultTransformFn)
}
}
function Select(mapFn=x => x){
const iter=this.getIterator();return new Collection(function *(){
for(let val of iter){
yield mapFn(val)
}
})
}
function Flatten(){
return this.SelectMany(x => x)
}
function SelectMany(mapFn,resultSelector=(x,y)=> y){
__b(mapFn);__b(resultSelector);const iter=this.getIterator();return new Collection(function *(){
let index=0;for(let current of iter){
let mappedEntry=mapFn(current,index);let newIter=mappedEntry;if(!isIterable(mappedEntry)){
newIter=[mappedEntry]
} else {
newIter=mappedEntry
}
for(let val of newIter[Symbol.iterator]()){
yield resultSelector(current,val)
}
index++
}
})
}
function Distinct(equalityCompareFn=defaultEqualityCompareFn){
__b(equalityCompareFn);return removeDuplicates(this,equalityCompareFn)
}
function ToArray(){
return [...this.getIterator()]
}
function ToDictionary(keySelector,elementSelectorOrKeyComparer,keyComparer){
__b(keySelector);if(!elementSelectorOrKeyComparer&&!keyComparer){
return this.ToDictionary(keySelector,elem => elem,defaultEqualityCompareFn)
} else if(!keyComparer&&getParameterCount(elementSelectorOrKeyComparer)===1){
return this.ToDictionary(keySelector,elementSelectorOrKeyComparer,defaultEqualityCompareFn)
} else if(!keyComparer&&getParameterCount(elementSelectorOrKeyComparer)===2){
return this.ToDictionary(keySelector,elem => elem,elementSelectorOrKeyComparer)
}
__b(keyComparer);__b(elementSelectorOrKeyComparer);let usedKeys=[];let result=new Map();const input=this.ToArray();const elementSelector=elementSelectorOrKeyComparer;for(let value of input){
let key=keySelector(value);let elem=elementSelector(value);__(key!=null,'Key is not allowed to be null!');__(!usedKeys.Any(x => keyComparer(x,key)),`Key '${key}' is already in use!`);usedKeys.push(key);result.set(key,elem)
}
return result
}
function ToJSON(){
return toJSON(this.ToArray())
}
function Reverse(){
const arr=this.ToArray();return new Collection(function *(){
for(let i=arr.length-1;i >= 0;i--){
yield arr[i]
}
})
}
function ForEach(fn){
__b(fn);for(let val of this.getIterator()){
fn(val)
}
}
function Add(value){
this.Insert(value,this.Count())
}
function Insert(value,index){
__(index >= 0&&index<=this.Count(),'Index is out of bounds!');const oldIter=this.ToArray();this.iterable=function *(){
yield* oldIter.slice(0,index);yield value;yield* oldIter.slice(index,oldIter.length)
}
this.reset()
}
function Remove(value){
let values=this.ToArray();const result=removeFromArray(values,value);if(!result){
return false
}
this.iterable=function *(){
yield* values
}
this.reset();return true
}
let OrderedLinqCollection=(function(){
function OrderedLinqCollection(iterable,comparator,heapConstructor){
__e(iterable);
__b(comparator);
__b(heapConstructor);
Collection.apply(this,[iterable]);
this.__comparator     =comparator;
this.__heapConstructor=heapConstructor;
}
OrderedLinqCollection.prototype.ThenBy=function ThenBy(additionalComparator){
__g(this);
if(isString(additionalComparator)){
additionalComparator=GetComparatorFromKeySelector(additionalComparator);
}
__b(additionalComparator);
let currentComparator=this.__comparator;
this.__comparator=(a,b)=> {
let res=currentComparator(a,b);
if(res!==0){
return res;
}
return additionalComparator(a,b);
};
return this;
};
OrderedLinqCollection.prototype.getIterator=function(){
const _self=this;return function *(){
yield* Reflect.construct(_self.__heapConstructor,[[..._self.iterable],_self.__comparator])
}()
}
return OrderedLinqCollection;
})();
function GetComparatorFromKeySelector(selector){
__h(selector);
if(selector===''){
return Collection.prototype.DefaultComparator;
}
if(!(selector.startsWith('[')||selector.startsWith('.'))){
selector=`.${selector}`;
}
let result;
eval(`result=function(a,b){ return Collection.prototype.DefaultComparator(a${selector},b${selector})}`);
return result;
}
function Order(){
return this.OrderBy(DefaultComparator);
}
function OrderDescending(){
return this.OrderByDescending(DefaultComparator);
}
function OrderBy(comparator){
if(isString(comparator)){
comparator=GetComparatorFromKeySelector(comparator);
}
__b(comparator);
return new OrderedLinqCollection(this,comparator,MinHeap);
};
function OrderByDescending(comparator){
if(isString(comparator)){
comparator=GetComparatorFromKeySelector(comparator);
}
__b(comparator);
return new OrderedLinqCollection(this,comparator,MaxHeap);
};
function Shuffle(){
return this.OrderBy(()=> Math.floor(Math.random()* 3)-1 )
}
function GroupBy(keySelector,...args){
const arr=this.ToArray();function isKeyComparer(arg){
let result=getParameterCount(arg)===2;try {
result=result&&arg(1,1)&&!arg(1,2)
} catch(err){
result=false
}
return result
}
function getKey(groups,key,keyComparer){
for(let groupKey of groups.keys()){
if(keyComparer(groupKey,key)){
return groupKey
}
}
return key
}
function groupByOneArgument(keySelector){
return groupBy(keySelector,elem => elem,undefined,defaultEqualityCompareFn)
}
function groupByTwoArguments(keySelector,second){
let keyComparer,elementSelector;if(isKeyComparer(second)){
keyComparer=second;elementSelector=elem => elem
} else {
keyComparer=defaultEqualityCompareFn;elementSelector=second
}
return groupByThreeArguments(keySelector,elementSelector,keyComparer)
}
function groupByThreeArguments(keySelector,second,third){
let keyComparer,elementSelector,resultSelector;if(isKeyComparer(third)){
keyComparer=third
} else {
resultSelector=third
}
if(getParameterCount(second)===2){
resultSelector=second
} else {
elementSelector=second
}
if(!keyComparer){
keyComparer=defaultEqualityCompareFn
}
if(!elementSelector){
elementSelector=elem => elem
}
return groupBy(keySelector,elementSelector,resultSelector,keyComparer)
}
function groupBy(keySelector,elementSelector,resultSelector,keyComparer){
__b(keySelector);__b(elementSelector);__(isUndefined(resultSelector)||isFunction(resultSelector),'resultSelector must be undefined or function!');__b(keyComparer);let groups=new Map();let result;for(let val of arr){
const key=getKey(groups,keySelector(val),keyComparer);const elem=elementSelector(val);if(groups.has(key)){
groups.get(key).push(elem)
} else {
groups.set(key,[elem])
}
}
if(resultSelector){
result=groups.ToArray().Select(g => resultSelector(...g))
} else {
result=groups
}
return result
}
let fn;switch(args.length){
case 0:;fn=groupByOneArgument;break;case 1:;fn=groupByTwoArguments;break;case 2:;fn=groupByThreeArguments;break;case 3:;fn=groupBy;break;default:;throw new Error('GroupBy parameter count can not be greater than 4!')
}
return fn(keySelector,...args)
}
__export({ DefaultComparator,Min,Max,Average,Sum,Concat,Union,Join,Except,Zip,Where,ConditionalWhere,Count,Any,All,ElementAt,Take,TakeWhile,TakeUntil,Skip,SkipWhile,SkipUntil,Contains,First,FirstOrDefault,Last,LastOrDefault,Single,SingleOrDefault,DefaultIfEmpty,DefaultComparator,MinHeap,MaxHeap,Aggregate,Distinct,Select,SelectMany,Flatten,Reverse,ToArray,ToDictionary,ToJSON,ForEach,Add,Insert,Remove,GetComparatorFromKeySelector,OrderedLinqCollection,Order,OrderBy,OrderDescending,OrderByDescending,Shuffle,GroupBy });__assign(Collection.prototype,linqjsExports);OrderedLinqCollection.prototype=__assign(__assign({},Collection.prototype),OrderedLinqCollection.prototype);
OrderedLinqCollection.prototype.constructor=OrderedLinqCollection;
const protosToApplyWrappers=[window.Array.prototype,window.Set.prototype,window.Map.prototype];Object.keys(Collection.prototype).forEach(k => {
for(let proto of protosToApplyWrappers){
proto[k]=function(...args){
return new Collection(this)[k](...args)
}
}
});return Collection
}()))
}());