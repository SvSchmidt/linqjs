/*!
 * linqjs v0.0.0
 * (c) Sven Schmidt 
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */
(function(){'use strict';
const window=this||(0,eval)('this');const DEBUG=!0;(function(Collection){try{if(typeof define==='function'&&define.amd){define(['require','exports'],function(){return Collection })} else if(exports&&module&&module.exports){exports=module.exports=Collection}} catch(err){window.Collection=Collection}}(function(){let linqjsExports={}
let Collection;Collection=(function(){function Collection(VOrGenerator){O(l(VOrGenerator)||m(VOrGenerator),'Parameter must be V or generator!');this.V=VOrGenerator}
Collection.prototype=(function(){function next(){if(!this.started){this.started=!0;this.zcator=this.x()}
return this.zcator.next()}
function c(){this.started=!1}
function x(){const zc=this.V;if(m(zc)){return zc()} else{return function*(){yield* zc}()}}return{next,c,x }}());Collection.prototype[Symbol.zcator]=function*(){let vc;while(!0){vc=this.next();if(vc.done){this.c();break}
yield vc.value}}
return Collection}());function From(V){return new Collection(V)}
function Range(start,count){H(count,0,Infinity);return new Collection(function*(){let i=start;while(i!=count+start){yield i++}})}
function Repeat(val,count){H(count,0,Infinity);return new Collection(function*(){for(let i=0;i<count;i++){yield val}})}Object.defineProperty(Collection,'Empty',{get:function(){return Collection.from([])}});const hc={From,from:From,Range,Repeat }
E(Collection,hc);function A(kc,lc){return a(kc)===a(lc)}
function defaultComparator(a,b){if(a<b){return -1}
if(b<a){return 1}
return 0}class AssertionError extends Error{constructor(expected,got){super(`Expected ${expected},got ${got}!`)}}
function O(nc,...args){if(!nc){if(args.length===1){throw new Error(msg)} else if(args.length===2){throw new AssertionError(...args)}}}
function L(pc){O(n(pc),'function',pc)}
function N(pc){O(q(pc),'array',pc)}
function I(coll){O(!o(coll),'Sequence is empty!')}
function J(obj){O(l(obj),'V',obj)}
function M(obj){O(p(obj),'collection',obj)}
function F(obj){O(h(obj),'string',obj)}
function G(obj){O(i(obj),'numeric value',obj)}function H(num,min,max=Infinity){G(num);O(num>=min&&num<=max,`Number must be between ${min} and ${max}!`)}
function K(coll,index){M(coll);O(i(index),'number',index);O(index>=0&&index<coll.Count(),'Index is out of bounds')}
function q(obj){return obj instanceof([]).constructor}
function n(obj){return typeof obj==='function'}
function i(n){return !isNaN(parseFloat(n))}
function o(coll){if(p(coll)){return o(coll.Take(1).ToArray())}
return coll.length===0}
function l(obj){return(Symbol.zcator in Object(obj))}
function h(obj){return typeof obj==='string'}
function p(obj){return obj instanceof Collection}function m(obj){return obj instanceof(function*(){}).constructor}
function g(obj){return typeof obj===typeof undefined}
function a(obj){return JSON.stringify(obj)}
function E(target,source){Object.assign(Object(target),source);return target}
function D(obj){E(linqjsExports,obj)}
function f(pc,value){return typeof pc==='undefined'?value:pc}
function C(coll,sc,tc,Q){L(tc);L(Q);I(coll);return Q([sc].concat(coll).reduce(tc))}
function e(coll,S=A){J(coll);L(S);const previous=[];return new Collection(function*(){const zc=coll.x();ic:for(let val of zc){jc:for(let prev of previous){if(S(val,prev)){continue ic}}
previous.push(val);yield val}})}
function d(arr,value){N(arr);let ocsBefore=[];let ocFound=!1;let vc;while((vc=arr.shift())&&!(ocFound=A(vc,value))){ocsBefore.push(vc)}
arr.unshift(...ocsBefore);return ocFound}
const ec=[Object,Number,Boolean,String,Symbol];function j(obj){return /native code/.test(Object(obj).toString())||!!~ec.indexOf(obj)}
function z(aa=Object){if(aa&&j(aa)&&typeof aa==='function'){let defaultValue=aa();if(defaultValue instanceof Object||aa===Date){return null} else{return defaultValue}}
return aa}
function w(fn){L(fn);return fn.length}
function Min(yc=x=>x){L(yc);I(this);return Math.min.apply(null,this.Select(yc).ToArray())}
function Max(yc=x=>x){L(yc);I(this);return Math.max.apply(null,this.Select(yc).ToArray())}
function Sum(yc=x=>x){I(this);return this.Select(yc).Aggregate(0,(prev,curr)=>prev+curr)}
function Average(yc=x=>x){I(this);return this.Sum(yc)/ this.Count()}
function Concat(jc){J(jc);const ic=this;return new Collection(function*(){yield* ic.x();yield* jc})}
function Union(jc,S=A){J(jc);return this.Concat(jc).Distinct(S)}
function Join(jc,T,U,PFn,mc){J(jc);L(T);L(U);L(PFn);mc=f(mc,A);L(mc);const ic=this;return new Collection(function*(){for(let icValue of ic.x()){const icKey=T(icValue);for(let jcValue of jc[Symbol.zcator]()){const jcKey=U(jcValue);if(mc(icKey,jcKey)){yield PFn(icValue,jcValue)}}}})}
function Except(jc){J(jc);if(!p(jc)){jc=new Collection(jc)}
const ic=this;return new Collection(function*(){for(let val of ic.x()){if(!jc.Contains(val)){yield val}}})}
function Zip(jc,PFn){J(jc);L(PFn);const ic=this;return new Collection(function*(){const jcIter=jc[Symbol.zcator]();for(let icVal of ic.x()){const jcNext=jcIter.next();if(jcNext.done){break}
yield PFn(icVal,jcNext.value)}})}
function Intersect(jc,S=A){J(jc);L(S);const icIter=this.ToArray();return new Collection(function*(){const jcIter=[...jc];for(let val of icIter){if(jcIter.Any(oc=>S(val,oc))){yield val}}})}
function IndexOf(ocent,S=A){L(S);const zc=this.x();let i=0;for(let val of zc){if(S(val,ocent)){return i}
i++}
return -1}
function LastIndexOf(ocent,S=A){L(S);const zc=this.x();let i=0;let lastIndex=-1;for(let val of zc){if(S(val,ocent)){lastIndex=i}
i++}
return lastIndex}
function Contains(oc,S=A){return !!~this.IndexOf(oc,S)}
function Where(dc=(oc,index)=>!0){L(dc);const zc=this.x();const result=new Collection(function*(){let index=0;for(let val of zc){if(dc(val,index)){yield val}
index++}});return result}
function ConditionalWhere(nc,dc){if(nc){return this.Where(dc)} else{return this}}
function Count(dc=oc=>!0){let count=0;
let filtered=this.Where(dc);
while(!filtered.next().done){count++}
return count}
function Any(dc){if(o(this)){return !1}
if(!dc){return !0}
return !this.Where(dc).next().done}
function All(dc=oc=>!0){L(dc);return !this.Any(x=>!dc(x))}
function b(collection,originalFn,dcOrDefault=x=>!0,fallback=Object){let dc;if(j(dcOrDefault)||!n(dcOrDefault)){dc=x=>!0;fallback=dcOrDefault} else{dc=dcOrDefault}
L(dc);const defaultVal=z(fallback);if(o(collection)){return defaultVal}
let result=originalFn.call(collection,dc);if(!result){return defaultVal}
return result}
function ElementAt(index){K(this,index);const result=this.Skip(index).Take(1).ToArray()[0];this.c();return result}
function Take(count=0){G(count);if(count<=0){return Collection.Empty}
const zc=this.x();return new Collection(function*(){let i=0;for(let val of zc){yield val;if(++i===count){break}}})}
function Skip(count=0){G(count);if(count<=0){return this}
const result=this.SkipWhile((oc,index)=>index<count);this.c();return result}
function TakeWhile(dc=(oc,index)=>!0){L(dc);const zc=this.x();const result=new Collection(function*(){let index=0;let endTake=!1;for(let val of zc){if(!endTake&&dc(val,index++)){yield val;continue}
endTake=!0}});this.c();return result}
function TakeUntil(dc=(oc,index)=>!1){return this.TakeWhile((oc,index)=>!dc(oc,index))}
function SkipWhile(dc=(oc,index)=>!0){L(dc);const zc=this.x();return new Collection(function*(){let index=0;let endSkip=!1;for(let val of zc){if(!endSkip&&dc(val,index++)){continue}
endSkip=!0;yield val}})}
function SkipUntil(dc=(oc,index)=>!1){return this.SkipWhile((oc,index)=>!dc(oc,index))}
function First(dc=x=>!0){L(dc);I(this);const result=this.SkipWhile(oc=>!dc(oc)).Take(1).ToArray()[0];this.c();return result}
function FirstOrDefault(dcOrConstructor=x=>!0,constructor=Object){return b(this,First,dcOrConstructor,constructor)}
function Last(dc=x=>!0){L(dc);I(this);return this.Reverse().First(dc)}
function LastOrDefault(dcOrConstructor=x=>!0,constructor=Object){return b(this,Last,dcOrConstructor,constructor)}
function Single(dc=x=>!0){L(dc);I(this);let index=0;let result;for(let val of this.x()){if(dc(val)){result=val;break}
index++}
if(this.First(oc=>dc(oc)&&!A(oc,result))){throw new Error('Sequence contains more than one ocent')}
return result}
function SingleOrDefault(dcOrConstructor=x=>!0,constructor=Object){return b(this,Single,dcOrConstructor,constructor)}
function DefaultIfEmpty(aa){if(!o(this)){return this}
return [z(aa)]}
let HeapElement=(function(){function HeapElement(index,value){this.__index=index;
this.__value=value;
this.__isHeapElementInstance=!0}
HeapElement.CreateHeapElement=function CreateHeapElement(index,obj){if(obj===undefined||obj.__isHeapElementInstance){return obj}
return new HeapElement(index,obj)};
return HeapElement})();
let MinHeap=(function(){function MinHeap(ocents,comparator=defaultComparator){N(ocents);
L(comparator);
this.ocents=ocents;
this.comparator=(a,b)=>{let res=comparator(a.__value,b.__value);
if(res!==0){return res}
return defaultComparator(a.__index,b.__index)};
B(this.ocents,this.comparator)}
function r(ocents,comparator,i){let right=2*(i+1);
let left=right-1;
let bestIndex=i;
ocents[bestIndex]=HeapElement.CreateHeapElement(bestIndex,ocents[bestIndex]);
if(left<ocents.length){ocents[left]=HeapElement.CreateHeapElement(left,ocents[left]);
if(comparator(ocents[left],ocents[bestIndex])<0){bestIndex=left}}
if(right<ocents.length){ocents[right]=HeapElement.CreateHeapElement(right,ocents[right]);
if(comparator(ocents[right],ocents[bestIndex])<0){bestIndex=right}}
if(bestIndex!==i){let tmp=ocents[i];
ocents[i]=ocents[bestIndex];
ocents[bestIndex]=tmp;
r(ocents,comparator,bestIndex)}}
function B(ocents,comparator){if(ocents.length===0){return}
for(let i=Math.floor(ocents.length / 2);i>=0;i--){r(ocents,comparator,i)}}
MinHeap.prototype.hasTopElement=function(){return this.ocents.length>0};
MinHeap.prototype.getTopElement=function(){if(this.ocents.length===1){return this.ocents.pop().__value}
let topElement=this.ocents[0];
let tmp=this.ocents.pop();
this.ocents[0]=tmp;
r(this.ocents,this.comparator,0);
return topElement.__value};
MinHeap.prototype[Symbol.zcator]=function(){let heap=this;
return{next:function(){if(heap.hasTopElement()){return{done:!1,
value:heap.getTopElement()}}
return{done:!0}}}};
return MinHeap})();
let MaxHeap=(function(){function MaxHeap(ocents,comparator=defaultComparator){N(ocents);
L(comparator);MinHeap.apply(this,[ocents,function(a,b){return -1*comparator(a,b)}])}
MaxHeap.prototype=Object.create(MinHeap.prototype);
MaxHeap.prototype.constructor=MaxHeap;
return MaxHeap})();function Aggregate(rc,tc,Q){const values=this.ToArray();if(typeof rc==='function'&&!tc&&!Q){return C(values.slice(1,values.length),values.slice(0,1)[0],rc,oc=>oc)} else if(typeof rc!=='function'&&typeof tc==='function'&&!Q){return C(values,rc,tc,oc=>oc)} else{return C(values,rc,tc,Q)}}
function Select(yc=x=>x){const zc=this.x();let index=0;return new Collection(function*(){for(let val of zc){yield yc(val,index);index ++}})}
function Flatten(){return this.SelectMany(x=>x)}
function SelectMany(yc,P=(x,y)=>y){L(yc);L(P);const zc=this.x();return new Collection(function*(){let index=0;for(let vc of zc){let uc=yc(vc,index);let newIter=uc;if(!l(uc)){newIter=[uc]} else{newIter=uc}
for(let val of newIter[Symbol.zcator]()){yield P(vc,val)}
index++}})}
function Distinct(S=A){L(S);return e(this,S)}
function ToArray(){return [...this.x()]}
function ToDictionary(W,R,X){L(W);if(!R&&!X){return this.ToDictionary(W,oc=>oc,A)} else if(!X&&w(R)===1){return this.ToDictionary(W,R,A)} else if(!X&&w(R)===2){return this.ToDictionary(W,oc=>oc,R)}L(X);L(R);let usedKeys=[];let result=new Map();const input=this.ToArray();const Y=R;for(let value of input){let key=W(value);let oc=Y(value);O(key!=null,'Key is not allowed to be null!');O(!usedKeys.Any(x=>X(x,key)),`Key '${key}' is already in use!`);usedKeys.push(key);result.set(key,oc)}
return result}
function ToJSON(){return a(this.ToArray())}
function Reverse(){const arr=this.ToArray();return new Collection(function*(){for(let i=arr.length-1;i>=0;i--){yield arr[i]}})}
function ForEach(fn){L(fn);for(let val of this.x()){fn(val)}}
function Add(value){this.Insert(value,this.Count())}
function Insert(value,index){O(index>=0&&index<=this.Count(),'Index is out of bounds!');const oldIter=this.ToArray();this.V=function*(){yield* oldIter.slice(0,index);yield value;yield* oldIter.slice(index,oldIter.length)}}
function Remove(value){let values=this.ToArray();const result=d(values,value);if(!result){return !1}
this.V=function*(){yield* values}
return !0}
let OrderedCollection=(function(){function OrderedCollection(V,comparator,heapConstructor){J(V);L(comparator);L(heapConstructor);Collection.apply(this,[V]);this.__comparator=comparator;this.__heapConstructor=heapConstructor}
OrderedCollection.prototype.ThenBy=function(qc){if(h(qc)){qc=GetComparatorFromKeySelector(qc)}
L(qc);
let vcComparator=this.__comparator;
this.__comparator=(a,b)=>{let res=vcComparator(a,b);
if(res!==0){return res}
return qc(a,b)};
return this};
OrderedCollection.prototype.x=function(){const _self=this;return function*(){yield* Reflect.construct(_self.__heapConstructor,[[..._self.V],_self.__comparator])}()}
return OrderedCollection})();
function GetComparatorFromKeySelector(selector){F(selector);if(selector===''){return defaultComparator}if(!(selector.startsWith('[')||selector.startsWith('.'))){selector=`.${selector}`}return new Function('comparator','a','b',`return comparator(a${selector},b${selector})`).bind(null,defaultComparator)}
function Order(){return this.OrderBy(defaultComparator)}
function OrderDescending(){return this.OrderByDescending(defaultComparator)}
function OrderBy(comparator){if(h(comparator)){comparator=GetComparatorFromKeySelector(comparator)}
L(comparator);
return new OrderedCollection(this,comparator,MinHeap)};
function OrderByDescending(comparator){if(h(comparator)){comparator=GetComparatorFromKeySelector(comparator)}
L(comparator);
return new OrderedCollection(this,comparator,MaxHeap)};
function Shuffle(){return this.OrderBy(()=>Math.floor(Math.random()*3)-1 )}
function y(groups,key,X){for(let groupKey of groups.keys()){if(X(groupKey,key)){return groupKey}}
return key}
function GroupBy(W,...args){const arr=this.ToArray();function k(arg){let result=w(arg)===2;try{result=result&&arg(1,1)&&!arg(1,2)} catch(err){result=!1}
return result}
function u(W){return v(W,oc=>oc,undefined,A)}
function s(W,jc){let X,Y;if(k(jc)){X=jc;Y=oc=>oc} else{X=A;Y=jc}
return t(W,Y,X)}
function t(W,jc,third){let X,Y,P;if(k(third)){X=third} else{P=third}
if(w(jc)===2){P=jc} else{Y=jc}
if(!X){X=A}
if(!Y){Y=oc=>oc}
return v(W,Y,P,X)}
function v(W,Y,P,X){L(W);L(Y);O(g(P)||n(P),'P must be undefined or function!');L(X);let groups=new Map();let result;for(let val of arr){const key=y(groups,W(val),X);const oc=Y(val);if(groups.has(key)){groups.get(key).push(oc)} else{groups.set(key,[oc])}}
if(P){result=groups.ToArray().Select(g=>P(...g))} else{result=groups}
return result}
let fn;switch(args.length){case 0:;fn=u;break;case 1:;fn=s;break;case 2:;fn=t;break;case 3:;fn=v;break;default:;throw new Error('GroupBy pceter count can not be greater than 4!')}
return fn(W,...args)}
function GroupJoin(jc,T,U,P,S=A){J(jc);L(T);L(U);L(P);let groups=new Map();const ic=this;for(let icVal of ic.x()){const icKey=T(icVal);groups.set(icVal,new Collection(function*(){for(let jcVal of jc[Symbol.zcator]()){if(S(icKey,U(jcVal))){yield jcVal}}}))}
return new Collection(function*(){for(let [key,values] of groups){yield P(key,values.ToArray())}})}
function SequenceEqual(lc,S=A){if(!l(lc)){return !1}
const kc=this.ToArray();lc=lc.ToArray();if(kc.length!==lc.length){return !1}
for(let i=0;i<kc.length;i++){let kcVal=kc[i];let lcVal=lc[i];if(!S(kcVal,lcVal)){return !1}}
return !0}D({defaultComparator,Min,Max,Average,Sum,Concat,Union,Join,Except,Zip,Intersect,Where,ConditionalWhere,Count,Contains,IndexOf,LastIndexOf,Any,All,ElementAt,Take,TakeWhile,TakeUntil,Skip,SkipWhile,SkipUntil,Contains,First,FirstOrDefault,Last,LastOrDefault,Single,SingleOrDefault,DefaultIfEmpty,MinHeap,MaxHeap,Aggregate,Distinct,Select,SelectMany,Flatten,Reverse,ToArray,ToDictionary,ToJSON,ForEach,Add,Insert,Remove,GetComparatorFromKeySelector,OrderedCollection,Order,OrderBy,OrderDescending,OrderByDescending,Shuffle,GroupBy,GroupJoin,SequenceEqual });E(Collection.prototype,linqjsExports);OrderedCollection.prototype=E(E({},Collection.prototype),OrderedCollection.prototype);OrderedCollection.prototype.constructor=OrderedCollection;const protosToApplyWrappers=[window.Array.prototype,window.Set.prototype,window.Map.prototype];Object.keys(Collection.prototype).forEach(k=>{for(let proto of protosToApplyWrappers){proto[k]=function(...args){return new Collection(this)[k](...args)}}});return Collection}()))}());