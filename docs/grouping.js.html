<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>grouping.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Collection.html">Collection</a><ul class='methods'><li data-type='method'><a href="Collection.html#.From">From (static)</a></li><li data-type='method'><a href="Collection.html#.Range">Range (static)</a></li><li data-type='method'><a href="Collection.html#.Repeat">Repeat (static)</a></li><li data-type='method'><a href="Collection.html#Add">Add</a></li><li data-type='method'><a href="Collection.html#Aggregateaccumulator">Aggregate(accumulator)</a></li><li data-type='method'><a href="Collection.html#Aggregateseed,accumulator">Aggregate(seed, accumulator)</a></li><li data-type='method'><a href="Collection.html#Aggregateseed,accumulator,resultTransformFn">Aggregate(seed, accumulator, resultTransformFn)</a></li><li data-type='method'><a href="Collection.html#All">All</a></li><li data-type='method'><a href="Collection.html#Any">Any</a></li><li data-type='method'><a href="Collection.html#Anypredicate">Any(predicate)</a></li><li data-type='method'><a href="Collection.html#Average">Average()</a></li><li data-type='method'><a href="Collection.html#AveragemapFn">Average(mapFn)</a></li><li data-type='method'><a href="Collection.html#Concat">Concat</a></li><li data-type='method'><a href="Collection.html#ConditionalWherecondition,(elem,index)=%253Ebool">ConditionalWhere(condition, (elem, index) => bool)</a></li><li data-type='method'><a href="Collection.html#ConditionalWherecondition,elem=%253Ebool">ConditionalWhere(condition, elem => bool)</a></li><li data-type='method'><a href="Collection.html#Containselem">Contains(elem)</a></li><li data-type='method'><a href="Collection.html#Containselem,equalityCompareFn">Contains(elem, equalityCompareFn)</a></li><li data-type='method'><a href="Collection.html#Count">Count()</a></li><li data-type='method'><a href="Collection.html#Countpredicate">Count(predicate)</a></li><li data-type='method'><a href="Collection.html#DefaultIfEmptyconstructor">DefaultIfEmpty(constructor)</a></li><li data-type='method'><a href="Collection.html#DefaultIfEmptydefaultValue">DefaultIfEmpty(defaultValue)</a></li><li data-type='method'><a href="Collection.html#Distinct">Distinct()</a></li><li data-type='method'><a href="Collection.html#DistinctequalityCompareFn">Distinct(equalityCompareFn)</a></li><li data-type='method'><a href="Collection.html#ElementAt">ElementAt</a></li><li data-type='method'><a href="Collection.html#Except">Except</a></li><li data-type='method'><a href="Collection.html#First">First()</a></li><li data-type='method'><a href="Collection.html#Firstpredicate">First(predicate)</a></li><li data-type='method'><a href="Collection.html#FirstOrDefault">FirstOrDefault()</a></li><li data-type='method'><a href="Collection.html#FirstOrDefaultpredicate">FirstOrDefault(predicate)</a></li><li data-type='method'><a href="Collection.html#Flatten">Flatten</a></li><li data-type='method'><a href="Collection.html#ForEach">ForEach</a></li><li data-type='method'><a href="Collection.html#GroupBykeySelector">GroupBy(keySelector)</a></li><li data-type='method'><a href="Collection.html#GroupBykeySelector,elementSelector">GroupBy(keySelector, elementSelector)</a></li><li data-type='method'><a href="Collection.html#GroupBykeySelector,elementSelector,keyComparer">GroupBy(keySelector, elementSelector, keyComparer)</a></li><li data-type='method'><a href="Collection.html#GroupBykeySelector,elementSelector,resultSelector">GroupBy(keySelector, elementSelector, resultSelector)</a></li><li data-type='method'><a href="Collection.html#GroupBykeySelector,elementSelector,resultSelector,keyComparer">GroupBy(keySelector, elementSelector, resultSelector, keyComparer)</a></li><li data-type='method'><a href="Collection.html#GroupBykeySelector,keyComparer">GroupBy(keySelector, keyComparer)</a></li><li data-type='method'><a href="Collection.html#GroupBykeySelector,resultSelector">GroupBy(keySelector, resultSelector)</a></li><li data-type='method'><a href="Collection.html#GroupBykeySelector,resultSelector,keyComparer">GroupBy(keySelector, resultSelector, keyComparer)</a></li><li data-type='method'><a href="Collection.html#GroupJoininner,outerKeySelector,innerKeySelector,resultSelector">GroupJoin(inner, outerKeySelector, innerKeySelector, resultSelector)</a></li><li data-type='method'><a href="Collection.html#GroupJoininner,outerKeySelector,innerKeySelector,resultSelector,keyComparer">GroupJoin(inner, outerKeySelector, innerKeySelector, resultSelector, keyComparer)</a></li><li data-type='method'><a href="Collection.html#IndexOf">IndexOf()</a></li><li data-type='method'><a href="Collection.html#IndexOfequalityCompareFn">IndexOf(equalityCompareFn)</a></li><li data-type='method'><a href="Collection.html#Insert">Insert</a></li><li data-type='method'><a href="Collection.html#Intersectinner">Intersect(inner)</a></li><li data-type='method'><a href="Collection.html#Intersectinner,equalityCompareFn">Intersect(inner, equalityCompareFn)</a></li><li data-type='method'><a href="Collection.html#Join">Join</a></li><li data-type='method'><a href="Collection.html#Last">Last()</a></li><li data-type='method'><a href="Collection.html#Lastpredicate">Last(predicate)</a></li><li data-type='method'><a href="Collection.html#LastIndexOf">LastIndexOf()</a></li><li data-type='method'><a href="Collection.html#LastIndexOfequalityCompareFn">LastIndexOf(equalityCompareFn)</a></li><li data-type='method'><a href="Collection.html#LastOrDefault">LastOrDefault()</a></li><li data-type='method'><a href="Collection.html#LastOrDefaultpredicate">LastOrDefault(predicate)</a></li><li data-type='method'><a href="Collection.html#Max">Max()</a></li><li data-type='method'><a href="Collection.html#MaxmapFn">Max(mapFn)</a></li><li data-type='method'><a href="Collection.html#Min">Min()</a></li><li data-type='method'><a href="Collection.html#MinmapFn">Min(mapFn)</a></li><li data-type='method'><a href="Collection.html#Order">Order()</a></li><li data-type='method'><a href="Collection.html#Ordercomparator">Order(comparator)</a></li><li data-type='method'><a href="Collection.html#OrderBykeySelector">OrderBy(keySelector)</a></li><li data-type='method'><a href="Collection.html#OrderBykeySelector,comparator">OrderBy(keySelector, comparator)</a></li><li data-type='method'><a href="Collection.html#OrderByDescendingkeySelector">OrderByDescending(keySelector)</a></li><li data-type='method'><a href="Collection.html#OrderByDescendingkeySelector,comparator">OrderByDescending(keySelector, comparator)</a></li><li data-type='method'><a href="Collection.html#OrderDescending">OrderDescending()</a></li><li data-type='method'><a href="Collection.html#OrderDescendingcomparator">OrderDescending(comparator)</a></li><li data-type='method'><a href="Collection.html#Remove">Remove</a></li><li data-type='method'><a href="Collection.html#Reverse">Reverse</a></li><li data-type='method'><a href="Collection.html#Select(elem,index)=%253Eany">Select((elem, index) => any)</a></li><li data-type='method'><a href="Collection.html#Selectelem=%253Eany">Select(elem => any)</a></li><li data-type='method'><a href="Collection.html#SelectMany(elem,index)=%253Eany">SelectMany((elem, index) => any)</a></li><li data-type='method'><a href="Collection.html#SelectMany(elem,index)=%253Eany,resultSelector">SelectMany((elem, index) => any, resultSelector)</a></li><li data-type='method'><a href="Collection.html#SelectManyelem=%253Eany">SelectMany(elem => any)</a></li><li data-type='method'><a href="Collection.html#SelectManyelem=%253Eany,resultSelector">SelectMany(elem => any, resultSelector)</a></li><li data-type='method'><a href="Collection.html#SequenceEqualsecond">SequenceEqual(second)</a></li><li data-type='method'><a href="Collection.html#SequenceEqualsecond,equalityCompareFn">SequenceEqual(second, equalityCompareFn)</a></li><li data-type='method'><a href="Collection.html#Shuffle">Shuffle</a></li><li data-type='method'><a href="Collection.html#Single">Single()</a></li><li data-type='method'><a href="Collection.html#Singlepredicate">Single(predicate)</a></li><li data-type='method'><a href="Collection.html#SingleOrDefault">SingleOrDefault()</a></li><li data-type='method'><a href="Collection.html#SingleOrDefaultpredicate">SingleOrDefault(predicate)</a></li><li data-type='method'><a href="Collection.html#Skip">Skip</a></li><li data-type='method'><a href="Collection.html#SkipUntil(elem,index)=%253Eboolean">SkipUntil((elem, index) => boolean)</a></li><li data-type='method'><a href="Collection.html#SkipUntilelem=%253Eboolean">SkipUntil(elem => boolean)</a></li><li data-type='method'><a href="Collection.html#SkipWhile(elem,index)=%253Eboolean">SkipWhile((elem, index) => boolean)</a></li><li data-type='method'><a href="Collection.html#SkipWhileelem=%253Eboolean">SkipWhile(elem => boolean)</a></li><li data-type='method'><a href="Collection.html#Sum">Sum()</a></li><li data-type='method'><a href="Collection.html#SummapFn">Sum(mapFn)</a></li><li data-type='method'><a href="Collection.html#Take">Take</a></li><li data-type='method'><a href="Collection.html#TakeUntil(elem,index)=%253Eboolean">TakeUntil((elem, index) => boolean)</a></li><li data-type='method'><a href="Collection.html#TakeUntilelem=%253Eboolean">TakeUntil(elem => boolean)</a></li><li data-type='method'><a href="Collection.html#TakeWhile(elem,index)=%253Eboolean">TakeWhile((elem, index) => boolean)</a></li><li data-type='method'><a href="Collection.html#TakeWhileelem=%253Eboolean">TakeWhile(elem => boolean)</a></li><li data-type='method'><a href="Collection.html#ToArray">ToArray</a></li><li data-type='method'><a href="Collection.html#ToDictionarykeySelector">ToDictionary(keySelector)</a></li><li data-type='method'><a href="Collection.html#ToDictionarykeySelector,elementSelector">ToDictionary(keySelector, elementSelector)</a></li><li data-type='method'><a href="Collection.html#ToDictionarykeySelector,elementSelector,keyComparer">ToDictionary(keySelector, elementSelector, keyComparer)</a></li><li data-type='method'><a href="Collection.html#ToDictionarykeySelector,keyComparer">ToDictionary(keySelector, keyComparer)</a></li><li data-type='method'><a href="Collection.html#ToJSON">ToJSON</a></li><li data-type='method'><a href="Collection.html#UnionequalityCompareFn">Union(equalityCompareFn)</a></li><li data-type='method'><a href="Collection.html#Unioninner">Union(inner)</a></li><li data-type='method'><a href="Collection.html#Where(elem,index)=%253Eboolean">Where((elem, index) => boolean)</a></li><li data-type='method'><a href="Collection.html#Whereelem=%253Eboolean">Where(elem => boolean)</a></li><li data-type='method'><a href="Collection.html#Zip">Zip</a></li></ul></li><li><a href="OrderedCollection.html">OrderedCollection</a><ul class='methods'><li data-type='method'><a href="OrderedCollection.html#ThenBykeySelector">ThenBy(keySelector)</a></li><li data-type='method'><a href="OrderedCollection.html#ThenBykeySelector,comparator">ThenBy(keySelector, comparator)</a></li><li data-type='method'><a href="OrderedCollection.html#ThenByDescendingkeySelector">ThenByDescending(keySelector)</a></li><li data-type='method'><a href="OrderedCollection.html#ThenByDescendingkeySelector,comparator">ThenByDescending(keySelector, comparator)</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#defaultComparator">defaultComparator</a></li><li><a href="global.html#GetComparatorFromKeySelector">GetComparatorFromKeySelector</a></li><li><a href="global.html#getEqualKey">getEqualKey</a></li><li><a href="global.html#HeapElement">HeapElement</a></li><li><a href="global.html#paramOrValue">paramOrValue</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">grouping.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * getEqualKey - Get the matching key in the group for a given key and a keyComparer or return the parameter itself if the key is not present yet
 */
function getEqualKey(groups, key, keyComparer) {
  for (let groupKey of groups.keys()) {
    if (keyComparer(groupKey, key)) {
      return groupKey
    }
  }

  return key
}

/**
 * GroupBy - Groups a sequence using the keys selected from the members using the keySelector
 *
 * @see https://msdn.microsoft.com/de-de/library/system.linq.enumerable.groupby(v=vs.110).aspx
 * @instance
 * @memberof Collection
 * @method
 * @variation (keySelector)
 * @example
 * // Map {"S" => ["Sven"], "M" => ["Mauz"]}
 * ['Sven', 'Mauz'].GroupBy(x => x[0])
 * @param {Function} keySelector A function to select grouping keys from the sequence members
 * @return {Map} The grouped sequence as a Map
 *//**
 * GroupBy - Groups a sequence using the keys selected from the members using the keySelector. The keys are compared using keyComparer.
 *
 * @see https://msdn.microsoft.com/de-de/library/system.linq.enumerable.groupby(v=vs.110).aspx
 * @instance
 * @memberof Collection
 * @method
 * @variation (keySelector, keyComparer)
 * @example
 * // Map {"4" => ["4", 4], "5" => ["5"]}
 * ['4', 4, '5'].GroupBy(x => x, (outer, inner) => parseInt(outer) === parseInt(inner))
 * @param {Function} keySelector A function to select grouping keys from the sequence members
 * @param {Function} keyComparer A function of the form (outer, inner) => bool to check if keys are considered equal
 * @return {Map} The grouped sequence as a Map
 *//**
 * GroupBy - Groups a sequence using the keys selected from the members using the keySelector.
 * Each group member is projected to a single value (e.g. a property) using the elementSelector.
 *
 * @see https://msdn.microsoft.com/de-de/library/system.linq.enumerable.groupby(v=vs.110).aspx
 * @instance
 * @memberof Collection
 * @method
 * @variation (keySelector, elementSelector)
 * @example
 * // Map {23 => ["Sven"], 20 => ["jon"]}
 * [{ name: 'Sven', age: 23 }, { name: 'jon', age: 20 }].GroupBy(x => x.age, x => x.name)
 * @param {Function} keySelector A function to select grouping keys from the sequence members
 * @param {Function} elementSelector A function to map each group member to a specific value
 * @return {Map} The grouped sequence as a Map
 *//**
 * GroupBy - Groups a sequence using the keys selected from the members using the keySelector.
 * The resultSelector is used to project each resulting group to a single value (e.g. an object with aggregated properties).
 *
 * @see https://msdn.microsoft.com/de-de/library/system.linq.enumerable.groupby(v=vs.110).aspx
 * @instance
 * @memberof Collection
 * @method
 * @variation (keySelector, resultSelector)
 * @example
 * // [ { age:23, persons: "Sven&amp;julia" }, { age: 20, persons: "jon" } ]
 * [{ name: 'Sven', age: 23 }, { name: 'julia', age: 23 }, { name: 'jon', age: 20 }].GroupBy(x => x.age, (age, persons) => ({ age, persons: persons.map(p => p.name).join('&amp;') })).ToArray()
 * @param {Function} keySelector A function to select grouping keys from the sequence members
 * @param {Function} resultSelector A function of the form (key, groupMembers) => any to select a final result from each group
 * @return {Collection} The grouped sequence with projected results as a new Collection
 *//**
 * GroupBy - Groups a sequence using the keys selected from the members using the keySelector. Keys are compared using the specified keyComparer.
 * The resultSelector is used to project each resulting group to a single value (e.g. an object with aggregated properties).
 *
 * @see https://msdn.microsoft.com/de-de/library/system.linq.enumerable.groupby(v=vs.110).aspx
 * @instance
 * @memberof Collection
 * @method
 * @variation (keySelector, resultSelector, keyComparer)
 * @param {Function} keySelector A function to select grouping keys from the sequence members
 * @param {Function} resultSelector A function of the form (key, groupMembers) => any to select a final result from each group
 * @param {Function} keyComparer A function of the form (outer, inner) => bool to check if keys are considered equal
 * @return {Collection} The grouped sequence with projected results as a new Collection
 *//**
 * GroupBy - Groups a sequence using the keys selected from the members using the keySelector. Keys are compared using the specified keyComparer.
 * Each group member is projected to a single value (e.g. a property) using the elementSelector.
 *
 * @see https://msdn.microsoft.com/de-de/library/system.linq.enumerable.groupby(v=vs.110).aspx
 * @instance
 * @memberof Collection
 * @method
 * @variation (keySelector, elementSelector, keyComparer)
 * @param {Function} keySelector A function to select grouping keys from the sequence members
 * @param {Function} elementSelector A function to map each group member to a specific value
 * @param {Function} keyComparer A function of the form (outer, inner) => bool to check if keys are considered equal
 * @return {Map} The grouped sequence as a Map
 *//**
 * GroupBy - Groups a sequence using the keys selected from the members using the keySelector.
 * Each group member is projected to a single value (e.g. a property) using the elementSelector.
 * The resultSelector is used to project each resulting group to a single value (e.g. an object with aggregated properties).
 *
 * @see https://msdn.microsoft.com/de-de/library/system.linq.enumerable.groupby(v=vs.110).aspx
 * @instance
 * @memberof Collection
 * @method
 * @variation (keySelector, elementSelector, resultSelector)
 * @param {Function} keySelector A function to select grouping keys from the sequence members
 * @param {Function} elementSelector A function to map each group member to a specific value
 * @param {Function} resultSelector A function of the form (key, groupMembers) => any to select a final result from each group
 * @return {Collection} The grouped sequence with projected results as a new Collection
 *//**
 * GroupBy - Groups a sequence using the keys selected from the members using the keySelector. The keys are compared using the keyComparer.
 * Each group member is projected to a single value (e.g. a property) using the elementSelector.
 * The resultSelector is used to project each resulting group to a single value (e.g. an object with aggregated properties).
 *
 * @see https://msdn.microsoft.com/de-de/library/system.linq.enumerable.groupby(v=vs.110).aspx
 * @instance
 * @memberof Collection
 * @method
 * @variation (keySelector, elementSelector, resultSelector, keyComparer)
 * @param {Function} keySelector A function to select grouping keys from the sequence members
 * @param {Function} elementSelector A function to map each group member to a specific value
 * @param {Function} resultSelector A function of the form (key, groupMembers) => any to select a final result from each group
 * @param {Function} keyComparer A function of the form (outer, inner) => bool to check if keys are considered equal
 * @return {Collection} The grouped sequence with projected results as a new Collection
 * @
 */
function GroupBy (keySelector, ...args) {
  const arr = this.ToArray()

  /**
   * isKeyComparer - Checks whether or not a function is a keyComparer. We need to differentiate between the keyComparer and the resultSelector
   * since both take two arguments.
   */
  function isKeyComparer (arg) {
    let result = getParameterCount(arg) === 2
    try {
      // if this is a key comparer, it must return truthy values for equal values and falsy ones if they're different
      result = result &amp;&amp; arg(1, 1) &amp;&amp; !arg(1, 2)
    } catch (err) {
      // if the function throws an error for values, it can't be a keyComparer
      result = false
    }

    return result
  }

  /*
  GroupBy(keySelector)
  */
  function groupByOneArgument (keySelector) {
    return groupBy(keySelector, elem => elem, undefined, defaultEqualityCompareFn)
  }

  /*
  GroupBy(keySelector, keyComparer)
  GroupBy(keySelector, elementSelector)
  GroupBy(keySelector, resultSelector)
  */
  function groupByTwoArguments (keySelector, inner) {
    let keyComparer, elementSelector

    if (isKeyComparer(inner)) {
      keyComparer = inner
      elementSelector = elem => elem
    } else {
      keyComparer = defaultEqualityCompareFn
      elementSelector = inner
    }

    return groupByThreeArguments(keySelector, elementSelector, keyComparer)
  }

  /*
  GroupBy(keySelector, resultSelector, keyComparer)
  GroupBy(keySelector, elementSelector, keyComparer)
  GroupBy(keySelector, elementSelector, resultSelector)
  */
  function groupByThreeArguments (keySelector, inner, third) {
    let keyComparer, elementSelector, resultSelector

    if (isKeyComparer(third)) {
      keyComparer = third
    } else {
      resultSelector = third
    }

    if (getParameterCount(inner) === 2) {
      resultSelector = inner
    } else {
      elementSelector = inner
    }

    if (!keyComparer) {
      keyComparer = defaultEqualityCompareFn
    }

    if (!elementSelector) {
      elementSelector = elem => elem
    }

    return groupBy(keySelector, elementSelector, resultSelector, keyComparer)
  }

  /**
   * This is the "basic" function to use. The others just transform their parameters to be used with this one.
   */
  function groupBy (keySelector, elementSelector, resultSelector, keyComparer) {
    __assertFunction(keySelector)
    __assertFunction(elementSelector)
    __assert(isUndefined(resultSelector) || isFunction(resultSelector), 'resultSelector must be undefined or function!')
    __assertFunction(keyComparer)

    let groups = new Map()
    let result

    for (let val of arr) {
      // Instead of checking groups.has we use our custom function since we want to treat some keys as equal even if they aren't for the Map
      const key = getEqualKey(groups, keySelector(val), keyComparer)
      const elem = elementSelector(val)

      if (groups.has(key)) {
        groups.get(key).push(elem)
      } else {
        groups.set(key, [elem])
      }
    }

    if (resultSelector) {
      // If we want to select the final result with the resultSelector, we use the built-in Select function and retrieve a new Collection
      result = groups.ToArray().Select(g => resultSelector(...g))
    } else {
      // our result is just the grouos -> return the Map
      result = groups
    }

    return result
  }

  // the outer parameter of GroupBy is always the keySelector, so we have to differentiate the following arguments
  // and select the appropriate function
  let fn
  switch (args.length) {
    case 0:
      fn = groupByOneArgument
      break
    case 1:
      fn = groupByTwoArguments
      break
    case 2:
      fn = groupByThreeArguments
      break
    case 3:
      fn = groupBy
      break
    default:
      throw new Error('GroupBy parameter count can not be greater than 4!')
  }

  return fn(keySelector, ...args)
}


/**
 * GroupJoin - Correlates the elements of two sequences based on equality of keys and groups the results.
 * The default equality comparer is used to compare keys.
 *
 * @instance
 * @memberof Collection
 * @method
 * @see https://msdn.microsoft.com/de-de/library/system.linq.enumerable.groupjoin(v=vs.110).aspx
 * @param  {Iterable} inner The values to join with this Collection
 * @param  {Function} outerKeySelector A function to extract the grouping keys from the outer Collection
 * @param  {Function} innerKeySelector A function to extract the grouping keys from the inner Collection
 * @param  {Function} resultSelector A function of the form (key, values) => any to select the final result from each grouping
 * @return {any}
 *//**
 * GroupJoin - Correlates the elements of two sequences based on equality of keys and groups the results.
 * The provided custom keyComparer is used to compare keys.
 *
 * @instance
 * @memberof Collection
 * @method
 * @see https://msdn.microsoft.com/de-de/library/system.linq.enumerable.groupjoin(v=vs.110).aspx
 * @param  {Iterable} inner The values to join with this Collection
 * @param  {Function} outerKeySelector A function to extract the grouping keys from the outer Collection
 * @param  {Function} innerKeySelector A function to extract the grouping keys from the inner Collection
 * @param  {Function} resultSelector A function of the form (key, values) => any to select the final result from each grouping
 * @param {Function} keyComparer A function of the form (first, second) => bool to compare keys for equality
 * @return {any}
 */
function GroupJoin (inner, outerKeySelector, innerKeySelector, resultSelector, equalityCompareFn = defaultEqualityCompareFn) {
  __assertIterable(inner)
  __assertFunction(outerKeySelector)
  __assertFunction(innerKeySelector)
  __assertFunction(resultSelector)

  let groups = new Map()
  const outer = this

  for (let outerVal of outer.getIterator()) {
    const outerKey = outerKeySelector(outerVal)

    groups.set(outerVal, new Collection(function * () {
      for (let innerVal of inner[Symbol.iterator]()) {
        if (equalityCompareFn(outerKey, innerKeySelector(innerVal))) {
          yield innerVal
        }
      }
    }))
  }

  return new Collection(function * () {
    for (let [key, values] of groups) {
      yield resultSelector(key, values.ToArray())
    }
  })
}

__export({ GroupBy, GroupJoin })
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.2</a> on Fri Oct 14 2016 14:06:56 GMT+0200 (CEST) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
