<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>grouping.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Collection.html">Collection</a><ul class='methods'><li data-type='method'><a href="Collection.html#.from">from (static)</a></li><li data-type='method'><a href="Collection.html#.Range">Range (static)</a></li><li data-type='method'><a href="Collection.html#.Repeat">Repeat (static)</a></li><li data-type='method'><a href="Collection.html#Add">Add</a></li><li data-type='method'><a href="Collection.html#Aggregate">Aggregate</a></li><li data-type='method'><a href="Collection.html#Aggregateaccumulator">Aggregate(accumulator)</a></li><li data-type='method'><a href="Collection.html#Aggregateseed,accumulator">Aggregate(seed, accumulator)</a></li><li data-type='method'><a href="Collection.html#All">All</a></li><li data-type='method'><a href="Collection.html#Any">Any</a></li><li data-type='method'><a href="Collection.html#AnyAny(predicate)">Any(Any(predicate))</a></li><li data-type='method'><a href="Collection.html#Average">Average()</a></li><li data-type='method'><a href="Collection.html#AveragemapFn">Average(mapFn)</a></li><li data-type='method'><a href="Collection.html#Concat">Concat</a></li><li data-type='method'><a href="Collection.html#ConditionalWhere1">ConditionalWhere(1)</a></li><li data-type='method'><a href="Collection.html#ConditionalWhere2">ConditionalWhere(2)</a></li><li data-type='method'><a href="Collection.html#Contains">Contains()</a></li><li data-type='method'><a href="Collection.html#ContainsequalityCompareFn">Contains(equalityCompareFn)</a></li><li data-type='method'><a href="Collection.html#Count">Count()</a></li><li data-type='method'><a href="Collection.html#Countpredicate">Count(predicate)</a></li><li data-type='method'><a href="Collection.html#DefaultIfEmptyconstructor">DefaultIfEmpty(constructor)</a></li><li data-type='method'><a href="Collection.html#DefaultIfEmptyvalue">DefaultIfEmpty(value)</a></li><li data-type='method'><a href="Collection.html#Distinct">Distinct()</a></li><li data-type='method'><a href="Collection.html#DistinctequalityCompareFn">Distinct(equalityCompareFn)</a></li><li data-type='method'><a href="Collection.html#ElementAt">ElementAt</a></li><li data-type='method'><a href="Collection.html#Except">Except</a></li><li data-type='method'><a href="Collection.html#First">First()</a></li><li data-type='method'><a href="Collection.html#Firstpredicate">First(predicate)</a></li><li data-type='method'><a href="Collection.html#FirstOrDefault">FirstOrDefault()</a></li><li data-type='method'><a href="Collection.html#FirstOrDefaultpredicate">FirstOrDefault(predicate)</a></li><li data-type='method'><a href="Collection.html#Flatten">Flatten</a></li><li data-type='method'><a href="Collection.html#ForEach">ForEach</a></li><li data-type='method'><a href="Collection.html#GroupBykeySelector">GroupBy(keySelector)</a></li><li data-type='method'><a href="Collection.html#GroupBykeySelector,elementSelector">GroupBy(keySelector, elementSelector)</a></li><li data-type='method'><a href="Collection.html#GroupBykeySelector,elementSelector,keyComparer">GroupBy(keySelector, elementSelector, keyComparer)</a></li><li data-type='method'><a href="Collection.html#GroupBykeySelector,elementSelector,resultSelector">GroupBy(keySelector, elementSelector, resultSelector)</a></li><li data-type='method'><a href="Collection.html#GroupBykeySelector,elementSelector,resultSelector,keyComparer">GroupBy(keySelector, elementSelector, resultSelector, keyComparer)</a></li><li data-type='method'><a href="Collection.html#GroupBykeySelector,keyComparer">GroupBy(keySelector, keyComparer)</a></li><li data-type='method'><a href="Collection.html#GroupBykeySelector,resultSelector">GroupBy(keySelector, resultSelector)</a></li><li data-type='method'><a href="Collection.html#GroupBykeySelector,resultSelector,keyComparer">GroupBy(keySelector, resultSelector, keyComparer)</a></li><li data-type='method'><a href="Collection.html#IndexOf">IndexOf()</a></li><li data-type='method'><a href="Collection.html#IndexOfequalityCompareFn">IndexOf(equalityCompareFn)</a></li><li data-type='method'><a href="Collection.html#Insert">Insert</a></li><li data-type='method'><a href="Collection.html#Intersectsecond">Intersect(second)</a></li><li data-type='method'><a href="Collection.html#Intersectsecond,equalityCompareFn">Intersect(second, equalityCompareFn)</a></li><li data-type='method'><a href="Collection.html#Last">Last()</a></li><li data-type='method'><a href="Collection.html#Lastpredicate">Last(predicate)</a></li><li data-type='method'><a href="Collection.html#LastIndexOf">LastIndexOf()</a></li><li data-type='method'><a href="Collection.html#LastIndexOfequalityCompareFn">LastIndexOf(equalityCompareFn)</a></li><li data-type='method'><a href="Collection.html#LastOrDefault">LastOrDefault()</a></li><li data-type='method'><a href="Collection.html#LastOrDefaultpredicate">LastOrDefault(predicate)</a></li><li data-type='method'><a href="Collection.html#Max">Max()</a></li><li data-type='method'><a href="Collection.html#MaxmapFn">Max(mapFn)</a></li><li data-type='method'><a href="Collection.html#Min">Min()</a></li><li data-type='method'><a href="Collection.html#MinmapFn">Min(mapFn)</a></li><li data-type='method'><a href="Collection.html#Remove">Remove</a></li><li data-type='method'><a href="Collection.html#Reverse">Reverse</a></li><li data-type='method'><a href="Collection.html#Select1">Select(1)</a></li><li data-type='method'><a href="Collection.html#Select2">Select(2)</a></li><li data-type='method'><a href="Collection.html#SelectMany1">SelectMany(1)</a></li><li data-type='method'><a href="Collection.html#SelectMany2">SelectMany(2)</a></li><li data-type='method'><a href="Collection.html#SelectMany3">SelectMany(3)</a></li><li data-type='method'><a href="Collection.html#SelectMany4">SelectMany(4)</a></li><li data-type='method'><a href="Collection.html#SequenceEqualsecond">SequenceEqual(second)</a></li><li data-type='method'><a href="Collection.html#SequenceEqualsecond,equalityCompareFn">SequenceEqual(second, equalityCompareFn)</a></li><li data-type='method'><a href="Collection.html#Shuffle">Shuffle</a></li><li data-type='method'><a href="Collection.html#Single">Single()</a></li><li data-type='method'><a href="Collection.html#Singlepredicate">Single(predicate)</a></li><li data-type='method'><a href="Collection.html#SingleOrDefault">SingleOrDefault()</a></li><li data-type='method'><a href="Collection.html#SingleOrDefaultpredicate">SingleOrDefault(predicate)</a></li><li data-type='method'><a href="Collection.html#Skip">Skip</a></li><li data-type='method'><a href="Collection.html#SkipUntil1">SkipUntil(1)</a></li><li data-type='method'><a href="Collection.html#SkipUntil2">SkipUntil(2)</a></li><li data-type='method'><a href="Collection.html#SkipWhile1">SkipWhile(1)</a></li><li data-type='method'><a href="Collection.html#SkipWhile2">SkipWhile(2)</a></li><li data-type='method'><a href="Collection.html#Sum">Sum()</a></li><li data-type='method'><a href="Collection.html#SummapFn">Sum(mapFn)</a></li><li data-type='method'><a href="Collection.html#Take">Take</a></li><li data-type='method'><a href="Collection.html#TakeUntil1">TakeUntil(1)</a></li><li data-type='method'><a href="Collection.html#TakeUntil2">TakeUntil(2)</a></li><li data-type='method'><a href="Collection.html#TakeWhile1">TakeWhile(1)</a></li><li data-type='method'><a href="Collection.html#TakeWhile2">TakeWhile(2)</a></li><li data-type='method'><a href="Collection.html#ToArray">ToArray</a></li><li data-type='method'><a href="Collection.html#ToDictionarykeySelector">ToDictionary(keySelector)</a></li><li data-type='method'><a href="Collection.html#ToDictionarykeySelector,elementSelector">ToDictionary(keySelector, elementSelector)</a></li><li data-type='method'><a href="Collection.html#ToDictionarykeySelector,elementSelector,keyComparer">ToDictionary(keySelector, elementSelector, keyComparer)</a></li><li data-type='method'><a href="Collection.html#ToDictionarykeySelector,keyComparer">ToDictionary(keySelector, keyComparer)</a></li><li data-type='method'><a href="Collection.html#ToJSON">ToJSON</a></li><li data-type='method'><a href="Collection.html#UnionequalityCompareFn">Union(equalityCompareFn)</a></li><li data-type='method'><a href="Collection.html#Unionsecond">Union(second)</a></li><li data-type='method'><a href="Collection.html#Where1">Where(1)</a></li><li data-type='method'><a href="Collection.html#Where2">Where(2)</a></li><li data-type='method'><a href="Collection.html#Zip">Zip</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#DefaultComparator">DefaultComparator</a></li><li><a href="global.html#GetComparatorFromKeySelector">GetComparatorFromKeySelector</a></li><li><a href="global.html#HeapElement">HeapElement</a></li><li><a href="global.html#Join">Join</a></li><li><a href="global.html#OrderBy">OrderBy</a></li><li><a href="global.html#OrderByDescending">OrderByDescending</a></li><li><a href="global.html#paramOrValue">paramOrValue</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">grouping.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * GroupBy - Groups a sequence using the keys selected from the members using the keySelector
 *
 * @see https://msdn.microsoft.com/de-de/library/system.linq.enumerable.groupby(v=vs.110).aspx
 * @instance
 * @memberof Collection
 * @method
 * @variation (keySelector)
 * @example
 * // Map {"S" => ["Sven"], "M" => ["Mauz"]}
 * ['Sven', 'Mauz'].GroupBy(x => x[0])
 * @param {Function} keySelector A function to select grouping keys from the sequence members
 * @return {Map} The grouped sequence as a Map
 *//**
 * GroupBy - Groups a sequence using the keys selected from the members using the keySelector. The keys are compared using keyComparer.
 *
 * @see https://msdn.microsoft.com/de-de/library/system.linq.enumerable.groupby(v=vs.110).aspx
 * @instance
 * @memberof Collection
 * @method
 * @variation (keySelector, keyComparer)
 * @example
 * // Map {"4" => ["4", 4], "5" => ["5"]}
 * ['4', 4, '5'].GroupBy(x => x, (first, second) => parseInt(first) === parseInt(second))
 * @param {Function} keySelector A function to select grouping keys from the sequence members
 * @param {Function} keyComparer A function of the form (first, second) => bool to check if keys are considered equal
 * @return {Map} The grouped sequence as a Map
 *//**
 * GroupBy - Groups a sequence using the keys selected from the members using the keySelector.
 * Each group member is projected to a single value (e.g. a property) using the elementSelector.
 *
 * @see https://msdn.microsoft.com/de-de/library/system.linq.enumerable.groupby(v=vs.110).aspx
 * @instance
 * @memberof Collection
 * @method
 * @variation (keySelector, elementSelector)
 * @example
 * // Map {23 => ["Sven"], 20 => ["jon"]}
 * [{ name: 'Sven', age: 23 }, { name: 'jon', age: 20 }].GroupBy(x => x.age, x => x.name)
 * @param {Function} keySelector A function to select grouping keys from the sequence members
 * @param {Function} elementSelector A function to map each group member to a specific value
 * @return {Map} The grouped sequence as a Map
 *//**
 * GroupBy - Groups a sequence using the keys selected from the members using the keySelector.
 * The resultSelector is used to project each resulting group to a single value (e.g. an object with aggregated properties).
 *
 * @see https://msdn.microsoft.com/de-de/library/system.linq.enumerable.groupby(v=vs.110).aspx
 * @instance
 * @memberof Collection
 * @method
 * @variation (keySelector, resultSelector)
 * @example
 * // [ { age:23, persons: "Sven&amp;julia" }, { age: 20, persons: "jon" } ]
 * [{ name: 'Sven', age: 23 }, { name: 'julia', age: 23 }, { name: 'jon', age: 20 }].GroupBy(x => x.age, (age, persons) => ({ age, persons: persons.map(p => p.name).join('&amp;') })).ToArray()
 * @param {Function} keySelector A function to select grouping keys from the sequence members
 * @param {Function} resultSelector A function of the form (key, groupMembers) => any to select a final result from each group
 * @return {Collection} The grouped sequence with projected results as a new Collection
 *//**
 * GroupBy - Groups a sequence using the keys selected from the members using the keySelector. Keys are compared using the specified keyComparer.
 * The resultSelector is used to project each resulting group to a single value (e.g. an object with aggregated properties).
 *
 * @see https://msdn.microsoft.com/de-de/library/system.linq.enumerable.groupby(v=vs.110).aspx
 * @instance
 * @memberof Collection
 * @method
 * @variation (keySelector, resultSelector, keyComparer)
 * @param {Function} keySelector A function to select grouping keys from the sequence members
 * @param {Function} resultSelector A function of the form (key, groupMembers) => any to select a final result from each group
 * @param {Function} keyComparer A function of the form (first, second) => bool to check if keys are considered equal
 * @return {Collection} The grouped sequence with projected results as a new Collection
 *//**
 * GroupBy - Groups a sequence using the keys selected from the members using the keySelector. Keys are compared using the specified keyComparer.
 * Each group member is projected to a single value (e.g. a property) using the elementSelector.
 *
 * @see https://msdn.microsoft.com/de-de/library/system.linq.enumerable.groupby(v=vs.110).aspx
 * @instance
 * @memberof Collection
 * @method
 * @variation (keySelector, elementSelector, keyComparer)
 * @param {Function} keySelector A function to select grouping keys from the sequence members
 * @param {Function} elementSelector A function to map each group member to a specific value
 * @param {Function} keyComparer A function of the form (first, second) => bool to check if keys are considered equal
 * @return {Map} The grouped sequence as a Map
 *//**
 * GroupBy - Groups a sequence using the keys selected from the members using the keySelector.
 * Each group member is projected to a single value (e.g. a property) using the elementSelector.
 * The resultSelector is used to project each resulting group to a single value (e.g. an object with aggregated properties).
 *
 * @see https://msdn.microsoft.com/de-de/library/system.linq.enumerable.groupby(v=vs.110).aspx
 * @instance
 * @memberof Collection
 * @method
 * @variation (keySelector, elementSelector, resultSelector)
 * @param {Function} keySelector A function to select grouping keys from the sequence members
 * @param {Function} elementSelector A function to map each group member to a specific value
 * @param {Function} resultSelector A function of the form (key, groupMembers) => any to select a final result from each group
 * @return {Collection} The grouped sequence with projected results as a new Collection
 *//**
 * GroupBy - Groups a sequence using the keys selected from the members using the keySelector. The keys are compared using the keyComparer.
 * Each group member is projected to a single value (e.g. a property) using the elementSelector.
 * The resultSelector is used to project each resulting group to a single value (e.g. an object with aggregated properties).
 *
 * @see https://msdn.microsoft.com/de-de/library/system.linq.enumerable.groupby(v=vs.110).aspx
 * @instance
 * @memberof Collection
 * @method
 * @variation (keySelector, elementSelector, resultSelector, keyComparer)
 * @param {Function} keySelector A function to select grouping keys from the sequence members
 * @param {Function} elementSelector A function to map each group member to a specific value
 * @param {Function} resultSelector A function of the form (key, groupMembers) => any to select a final result from each group
 * @param {Function} keyComparer A function of the form (first, second) => bool to check if keys are considered equal
 * @return {Collection} The grouped sequence with projected results as a new Collection
 * @
 */
function GroupBy (keySelector, ...args) {
  const arr = this.ToArray()

  /**
   * isKeyComparer - Checks whether or not a function is a keyComparer. We need to differentiate between the keyComparer and the resultSelector
   * since both take two arguments.
   */
  function isKeyComparer (arg) {
    let result = getParameterCount(arg) === 2
    try {
      // if this is a key comparer, it must return truthy values for equal values and falsy ones if they're different
      result = result &amp;&amp; arg(1, 1) &amp;&amp; !arg(1, 2)
    } catch (err) {
      // if the function throws an error for values, it can't be a keyComparer
      result = false
    }

    return result
  }

  /**
   * getKey - Get the matching key in the group for a given key and a keyComparer or return the parameter itself if the key is not present yet
   */
  function getKey(groups, key, keyComparer) {
    for (let groupKey of groups.keys()) {
      if (keyComparer(groupKey, key)) {
        return groupKey
      }
    }

    return key
  }

  /*
  GroupBy(keySelector)
  */
  function groupByOneArgument (keySelector) {
    return groupBy(keySelector, elem => elem, undefined, defaultEqualityCompareFn)
  }

  /*
  GroupBy(keySelector, keyComparer)
  GroupBy(keySelector, elementSelector)
  GroupBy(keySelector, resultSelector)
  */
  function groupByTwoArguments (keySelector, second) {
    let keyComparer, elementSelector

    if (isKeyComparer(second)) {
      keyComparer = second
      elementSelector = elem => elem
    } else {
      keyComparer = defaultEqualityCompareFn
      elementSelector = second
    }

    return groupByThreeArguments(keySelector, elementSelector, keyComparer)
  }

  /*
  GroupBy(keySelector, resultSelector, keyComparer)
  GroupBy(keySelector, elementSelector, keyComparer)
  GroupBy(keySelector, elementSelector, resultSelector)
  */
  function groupByThreeArguments (keySelector, second, third) {
    let keyComparer, elementSelector, resultSelector

    if (isKeyComparer(third)) {
      keyComparer = third
    } else {
      resultSelector = third
    }

    if (getParameterCount(second) === 2) {
      resultSelector = second
    } else {
      elementSelector = second
    }

    if (!keyComparer) {
      keyComparer = defaultEqualityCompareFn
    }

    if (!elementSelector) {
      elementSelector = elem => elem
    }

    return groupBy(keySelector, elementSelector, resultSelector, keyComparer)
  }

  /**
   * This is the "basic" function to use. The others just transform their parameters to be used with this one.
   */
  function groupBy (keySelector, elementSelector, resultSelector, keyComparer) {
    __assertFunction(keySelector)
    __assertFunction(elementSelector)
    __assert(isUndefined(resultSelector) || isFunction(resultSelector), 'resultSelector must be undefined or function!')
    __assertFunction(keyComparer)

    let groups = new Map()
    let result

    for (let val of arr) {
      // Instead of checking groups.has we use our custom function since we want to treat some keys as equal even if they aren't for the Map
      const key = getKey(groups, keySelector(val), keyComparer)
      const elem = elementSelector(val)

      if (groups.has(key)) {
        groups.get(key).push(elem)
      } else {
        groups.set(key, [elem])
      }
    }

    if (resultSelector) {
      // If we want to select the final result with the resultSelector, we use the built-in Select function and retrieve a new Collection
      result = groups.ToArray().Select(g => resultSelector(...g))
    } else {
      // our result is just the grouos -> return the Map
      result = groups
    }

    return result
  }

  // the first parameter of GroupBy is always the keySelector, so we have to differentiate the following arguments
  // and select the appropriate function
  let fn
  switch (args.length) {
    case 0:
      fn = groupByOneArgument
      break
    case 1:
      fn = groupByTwoArguments
      break
    case 2:
      fn = groupByThreeArguments
      break
    case 3:
      fn = groupBy
      break
    default:
      throw new Error('GroupBy parameter count can not be greater than 4!')
  }

  return fn(keySelector, ...args)
}

__export({ GroupBy })
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.2</a> on Tue Oct 04 2016 21:23:15 GMT+0200 (CEST) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
